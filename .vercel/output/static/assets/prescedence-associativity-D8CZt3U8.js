import{j as e}from"./main-BXy83AsK.js";let o="\n\nOperators have the following precedences, from highest to lowest:\n\n* Unary precedence: `-`, `!`, `<-`\n* Cast precedence: `as`, `as?`, `as!`\n* Multiplication precedence: `*`, `/`, `%`\n* Addition precedence: `+`, `-`\n* Bitwise shift precedence: `<<`, `>>`\n* Bitwise conjunction precedence: `&`\n* Bitwise exclusive disjunction precedence: `^`\n* Bitwise disjunction precedence: `|`\n* Nil-coalescing precedence: `??`\n* Relational precedence: `<`, `<=`, `>`, `>=`\n* Equality precedence: `==`, `!=`\n* Logical conjunction precedence: `&&`\n* Logical disjunction precedence: `||`\n* Ternary precedence: `? :`\n\nAll operators are left-associative, except for the following operators, which are right-associative:\n\n* Ternary operator\n* Nil-coalescing operator\n\nExpressions can be wrapped in parentheses to override precedence conventions (i.e., an alternate order should be indicated), or when the default order should be emphasized (e.g., to avoid confusion). For example, `(2 + 3) * 4` forces addition to precede multiplication, and `5 + (6 * 7)` reinforces the default order.\n\n{/* Relative links. Will not render on the page */}\n",r={title:"Prescedence and Associativity"},t={contents:[{heading:void 0,content:"Operators have the following precedences, from highest to lowest:"},{heading:void 0,content:"Unary precedence: `-`, `!`, `<-`"},{heading:void 0,content:"Cast precedence: `as`, `as?`, `as!`"},{heading:void 0,content:"Multiplication precedence: `*`, `/`, `%`"},{heading:void 0,content:"Addition precedence: `+`, `-`"},{heading:void 0,content:"Bitwise shift precedence: `<<`, `>>`"},{heading:void 0,content:"Bitwise conjunction precedence: `&`"},{heading:void 0,content:"Bitwise exclusive disjunction precedence: `^`"},{heading:void 0,content:"Bitwise disjunction precedence: `|`"},{heading:void 0,content:"Nil-coalescing precedence: `??`"},{heading:void 0,content:"Relational precedence: `<`, `<=`, `>`, `>=`"},{heading:void 0,content:"Equality precedence: `==`, `!=`"},{heading:void 0,content:"Logical conjunction precedence: `&&`"},{heading:void 0,content:"Logical disjunction precedence: `||`"},{heading:void 0,content:"Ternary precedence: `? :`"},{heading:void 0,content:"All operators are left-associative, except for the following operators, which are right-associative:"},{heading:void 0,content:"Ternary operator"},{heading:void 0,content:"Nil-coalescing operator"},{heading:void 0,content:"Expressions can be wrapped in parentheses to override precedence conventions (i.e., an alternate order should be indicated), or when the default order should be emphasized (e.g., to avoid confusion). For example, `(2 + 3) * 4` forces addition to precede multiplication, and `5 + (6 * 7)` reinforces the default order."}],headings:[]};const s=[];function i(c){const n={code:"code",li:"li",p:"p",ul:"ul",...c.components};return e.jsxs(e.Fragment,{children:[e.jsx(n.p,{children:"Operators have the following precedences, from highest to lowest:"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsxs(n.li,{children:["Unary precedence: ",e.jsx(n.code,{children:"-"}),", ",e.jsx(n.code,{children:"!"}),", ",e.jsx(n.code,{children:"<-"})]}),`
`,e.jsxs(n.li,{children:["Cast precedence: ",e.jsx(n.code,{children:"as"}),", ",e.jsx(n.code,{children:"as?"}),", ",e.jsx(n.code,{children:"as!"})]}),`
`,e.jsxs(n.li,{children:["Multiplication precedence: ",e.jsx(n.code,{children:"*"}),", ",e.jsx(n.code,{children:"/"}),", ",e.jsx(n.code,{children:"%"})]}),`
`,e.jsxs(n.li,{children:["Addition precedence: ",e.jsx(n.code,{children:"+"}),", ",e.jsx(n.code,{children:"-"})]}),`
`,e.jsxs(n.li,{children:["Bitwise shift precedence: ",e.jsx(n.code,{children:"<<"}),", ",e.jsx(n.code,{children:">>"})]}),`
`,e.jsxs(n.li,{children:["Bitwise conjunction precedence: ",e.jsx(n.code,{children:"&"})]}),`
`,e.jsxs(n.li,{children:["Bitwise exclusive disjunction precedence: ",e.jsx(n.code,{children:"^"})]}),`
`,e.jsxs(n.li,{children:["Bitwise disjunction precedence: ",e.jsx(n.code,{children:"|"})]}),`
`,e.jsxs(n.li,{children:["Nil-coalescing precedence: ",e.jsx(n.code,{children:"??"})]}),`
`,e.jsxs(n.li,{children:["Relational precedence: ",e.jsx(n.code,{children:"<"}),", ",e.jsx(n.code,{children:"<="}),", ",e.jsx(n.code,{children:">"}),", ",e.jsx(n.code,{children:">="})]}),`
`,e.jsxs(n.li,{children:["Equality precedence: ",e.jsx(n.code,{children:"=="}),", ",e.jsx(n.code,{children:"!="})]}),`
`,e.jsxs(n.li,{children:["Logical conjunction precedence: ",e.jsx(n.code,{children:"&&"})]}),`
`,e.jsxs(n.li,{children:["Logical disjunction precedence: ",e.jsx(n.code,{children:"||"})]}),`
`,e.jsxs(n.li,{children:["Ternary precedence: ",e.jsx(n.code,{children:"? :"})]}),`
`]}),`
`,e.jsx(n.p,{children:"All operators are left-associative, except for the following operators, which are right-associative:"}),`
`,e.jsxs(n.ul,{children:[`
`,e.jsx(n.li,{children:"Ternary operator"}),`
`,e.jsx(n.li,{children:"Nil-coalescing operator"}),`
`]}),`
`,e.jsxs(n.p,{children:["Expressions can be wrapped in parentheses to override precedence conventions (i.e., an alternate order should be indicated), or when the default order should be emphasized (e.g., to avoid confusion). For example, ",e.jsx(n.code,{children:"(2 + 3) * 4"})," forces addition to precede multiplication, and ",e.jsx(n.code,{children:"5 + (6 * 7)"})," reinforces the default order."]}),`
`]})}function l(c={}){const{wrapper:n}=c.components||{};return n?e.jsx(n,{...c,children:e.jsx(i,{...c})}):i(c)}export{o as _markdown,l as default,r as frontmatter,t as structuredData,s as toc};
