import{j as e}from"./main-BXy83AsK.js";const a="/assets/ethereum-ownership-Cx6aFeKC.png",s="/assets/account-structure-B0nHUUMs.png",o="/assets/access-based-security-Bjg_59ZM.png",r="/assets/capability-based-security-DZU9xqdc.png";let l=`









Cadence introduces a different way to approach smart contract development, which may feel unfamiliar to Solidity developers. There are fundamental mindset and platform differences, and also several new language features that have no real equivalent in Solidity. As a result, while you can make similar programs in Cadence as you could in Solidity, a direct translation from one to the other isn't possible - similar to how you could make a note-taking app in C or in JavaScript, but it wouldn't be possible to directly translate the C code into JavaScript. You'd have to write an entirely new program for a new paradigm.

This guide outlines high level design and conceptual aspects of Flow and Cadence that are essential to understand, platform and integration differences, as well as detailed guidance on how to perform certain common Solidity development tasks using Cadence idioms. We also provide details on how to best leverage Cadence's unique features and how to avoid common pitfalls that may come up while transitioning.

Conceptual foundations for Cadence [#conceptual-foundations-for-cadence]

A fundamental difference to get used to when adjusting to Cadence from Solidity is **mindset**. Security and interoperability on Ethereum are designed around addresses (or more specifically, the account associated with an address), resulting in all contracts having to carefully track and evaluate access and authorizations.

<img alt="Ethereum Ownership" src={__img0} placeholder="blur" />

Transactions are based on who authorized them, which is provided as \`msg.sender\` in the transaction context. User-to-contract, or contract-to-contract interactions, must be explicitly coded **in the contract and in advance** to ensure the appropriate approvals have been made before interacting with a contract. The contract-based nature of storage means that user ownership in Ethereum is represented in a mapping (e.g., from owner to balance or token ID to owner). Put another way, ownership is tracked in ledger records similar to a person's bank balance. Crypto wallets help combine balances from multiple token types into a convenient view for the user.

Cadence introduces new primitives and distinct functionalities, namely [Resources] and [Capabilities], that are designed around Flow's account model. Resources are first-class language types, which are unique, non-copyable, and cannot be discarded. These properties make resources ideal for representing digital assets like currency or tokens that are always limited in number. Resources are always stored in account storage, and contracts control access to them using capabilities. Capabilities are another special type that secures protected resources without the need for tracking addresses. Cadence makes working with these straightforward and intuitive to those familiar with object-oriented programming languages.

Scripts and transactions [#scripts-and-transactions]

One of the most important (and powerful!) difference between Cadence and Solidity is that deployed contracts are not the only code being executed in the VM. Cadence offers scripts and transactions, which are written in Cadence and always exist offchain. However, they are the top-level code payload being executed by the execution runtime. Clients send scripts and transactions through the Flow Access API gRPC or REST endpoints, returning results to clients when applicable.

Scripts and transactions enable more efficient and powerful ways to integrate dapps with the underlying blockchain, where contracts can more purely be thought of as services or components, with scripts or transactions becoming the dapp-specific API interface for chain interactions.

What this means is that you **don't have to predict the future** when writing your contracts and your **views aren't limited to functions in the contract**. Even more importantly, you can **write transactions that call multiple functions with multiple deployed contracts that you don't need to own** and are signed with one signature.

Scripts are read-only in nature, requiring only a \`main\` function declaration that performs [queries] against a chain state. For example:

\`\`\`jsx
// This script reads the balance field of an account's ExampleToken Balance
import FungibleToken from "../../contracts/FungibleToken.cdc"
import ExampleToken from "../../contracts/ExampleToken.cdc"

access(all)
fun main(account: Address): UFix64 {
    let acct = getAccount(account)
    let vaultRef = acct.capabilities
        .borrow<&ExampleToken.Vault>(ExampleToken.VaultPublicPath)
        ?? panic("Could not borrow Balance reference to the Vault")

    return vaultRef.balance
}
\`\`\`

[Transactions] are an Atomic, Consistent, Isolated, and Durable (ACID) version of scripts having only \`prepare\` and \`execute\` functions that either succeed in full and mutate the chain state as described, or otherwise fail and mutate nothing. They also support a setting of \`pre\` and \`post\` conditions. In the following transaction example, \`ExampleToken\`s are deposited into multiple \`receiver\` vaults for each address in the input map:

\`\`\`jsx
import FungibleToken from "../contracts/FungibleToken.cdc"
import ExampleToken from "../contracts/ExampleToken.cdc"

/// Transfers tokens to a list of addresses specified in the \`addressAmountMap\` parameter
transaction(addressAmountMap: {Address: UFix64}) {

    // The Vault resource that holds the tokens that are being transferred
    let vaultRef: auth(FungibleToken.Withdraw) &ExampleToken.Vault

    prepare(signer: auth(BorrowValue) &Account) {

        // Get a reference to the signer's stored ExampleToken vault
        self.vaultRef = signer.storage.borrow<auth(FungibleToken.Withdraw) &ExampleToken.Vault>(
            from: ExampleToken.VaultStoragePath
       )     ?? panic("The signer does not store an ExampleToken.Vault object at the path "
                    .concat(ExampleToken.VaultStoragePath.toString())
                    .concat(". The signer must initialize their account with this vault first!"))
    }

    execute {

        for address in addressAmountMap.keys {

            // Withdraw tokens from the signer's stored vault
            let sentVault <- self.vaultRef.withdraw(amount: addressAmountMap[address]!)

            // Get the recipient's public account object
            let recipient = getAccount(address)

            // Get a reference to the recipient's Receiver
            let receiverRef = recipient.capabilities
                .borrow<&{FungibleToken.Receiver}>(ExampleToken.ReceiverPublicPath)
                ?? panic("Could not borrow receiver reference to the recipient's Vault")

            // Deposit the withdrawn tokens in the recipient's receiver
            receiverRef.deposit(from: <-sentVault)

        }
    }
}
\`\`\`

Transactions can encompass an arbitrary number of withdrawals/deposits across multiple FTs, sending to multiple addresses or other more complex variations, all of which will succeed or fail in their entirety given their ACID properties.

Flow account model [#flow-account-model]

The [Flow account model] in Cadence combines storage for the keys and code ("smart contracts") associated with an account with storage for the assets owned by that account. That's right — in Cadence, your tokens are stored in your account, and not in a smart contract. Of course, smart contracts still define these assets and how they behave, but those assets can be securely stored in a user's account through the magic of Resources:

<img alt="Account Structure" src={__img1} placeholder="blur" />

There is only one account type in Cadence that uses an account address, similar to an Externally-Owned-Account (EOA) address in Ethereum. Unlike Ethereum contracts, Cadence accounts directly store contract code. Accounts realize ownership on Flow by being the container where keys, resources, and contracts are stored onchain.

Account [#account]

\`Account\` is the type that provides access to an account.

The \`getAccount\` function allows you to get access to the publicly available functions and fields of an account. For example, this allows querying an account's balance.

An authorized \`Account\` reference provides access and allows the management of the account's storage, key configuration, and contract code. An authorized \`Account\` reference can only be acquired by signing a transaction. Capabilities ensure that resources held in an account can be safely shared and accessed.

Resources [#resources]

Resources are unique, [linear types] that can never be copied or implicitly discarded, and can only be moved between accounts. Static checks during development flag an error for a failure to store a resource moved from an account if that resource is not appropriately moved back into storage for a same or new account, or explicitly destroyed. The run-time enforces the same strict rules in terms of allowed operations. Therefore, contract functions that do not properly handle resources in scope before exiting will abort, reverting the resource to the original storage. These features of resources make them perfect for representing tokens, both fungible and non-fungible. Ownership is tracked by where they are stored, and the assets can't be duplicated or accidentally lost since the language itself enforces correctness.

Flow encourages the storage of data and compute onchain and resource-types makes this easier than ever. Since resources are always stored in accounts, any data and code that exists in resource instances is seamlessly managed onchain without any explicit handling needed.

Capability-based access [#capability-based-access]

Remote access to stored objects is managed via [Capabilities]. This means that if an account wants to be able to access another account's stored objects, it must have been provided with a valid capability to that object. Capabilities can be either public or private. An account can share a public capability if it wants to give all other accounts access. For example, it's common for an account to accept fungible token deposits from all sources via a public capability. Alternatively, an account can grant private capabilities to specific accounts in order to provide access to restricted functionality. For example, a non-fungible token (NFT) project often controls minting through an "administrator capability" that grants specific accounts the power to mint new tokens.

Contract standards [#contract-standards]

There are numerous widely-used contract standards established to benefit the ecosystem. For example, [Fungible Token] (FT) and [Non-Fungible Token] (NFT) are standards that are conceptually equivalent to Ethereum's ERC-20 and ERC-721 standards. Cadence's object-oriented design means standards apply through contract sub-types such as resources, resource interfaces, or other types declared in the contract standard. Standards can define and limit behavior and/or set conditions that implementations of the standard cannot violate.

Detailed information about available standards and other core contracts can be found in the [Introduction to Flow].

NFT standard and metadata [#nft-standard-and-metadata]

Solidity must manage NFT metadata offchain, and NFTs frequently link to IPFS-hosted JSON from onchain.

The Cadence NFT standard provides built-in support for metadata with specific types called [views]. Views can be added to NFTs when minted and will always be available as part of the NFT. While metadata is stored onchain, graphics and video content are stored offchain. Cadence provides [utility views] for both HTTP- and IPFS-based media storage, which remain linked to your NFT.

Using NFT metadata views is a requirement to get listed in the [Flow NFT Catalog]. Projects are encouraged to leverage the NFT catalog since wallets and other ecosystem partners can seamlessly integrate new collections added there with no input from project creators.

NFT metadata on Flow opens the door to exciting new possibilities that help builders innovate. Check out this recent [case study] where a community partner leveraged SVG-based metadata to make combined 2D + 3D versions of their PFPs, all onchain inside the NFTs' metadata!

Under most circumstances, NFTs bridged via the [Cross-VM Bridge] from Flow Cadence to Flow EVM will automatically be provided with

Security and access control [#security-and-access-control]

Decentralized application development places significant focus on security and access, which can fairly be described as security engineering. Understanding how resources, capabilities, and the account model solve this may not be obvious when viewed from a Solidity perspective.

msg.sender considered harmful [#msgsender-considered-harmful]

The first question that every Solidity developer asks when they start programming in Cadence is:

***How do I get the account that authorized the transaction?***

In Ethereum, this account is referred to as \`msg.sender\` and it informs the program flow in a function depending on who authorized it. Doing so is key to access and security, and is the basis of identity and ownership on Ethereum.

Cadence does not support \`msg.sender\`, and there is no transaction-level way for Cadence code to uniquely identify the calling account. Even if there was a way to access it, Cadence supports [multi-sig] transactions, meaning that a list of all the signers' accounts would be returned, making it impossible to identify a single authorizer.

The reason \`msg.sender\` is both unsupported and strongly advised against is that Cadence uses capabilities for access rather than addresses. The mindset change that developers need to adjust to is that a capability must first be obtained by the authorizing account (called the provider or signer in Cadence) from the contract that will require it, which then enables the requesting account to access the protected function or resource. This means the contract never needs to know who the signer is before proceeding because the capability **IS** the authorization.

In EVM, the contract grants access to an address or addresses, thus it must know and operate based on the address of the signer:

<img alt="Access-Based Security" src={__img2} placeholder="blur" />

The [capability-based security] model of Cadence frames access in the opposite direction from the [access-based security] model. Accounts are granted and store the capability to access and use functionality on the contract:

<img alt="Capability-Based Security" src={__img3} placeholder="blur" />

Access control using capabilities [#access-control-using-capabilities]

Solidity lacks specific types or other primitives to aid with permission management. Developers must inline guards to \`require\` at every function entry point, thus validating the \`msg.sender\` of the transaction.

[Capabilities] are defined by linking storage paths (namespaces for contract storage) to protected objects and then making that linked capability available to other accounts.

Any account can get access to an account's public capabilities. Public capabilities are created using public paths (i.e., they have the domain \`public\`). For example, all accounts have a default public capability linked to the \`FlowToken.Vault\` resource. This vault is exposed as a public [unentitled] capability, allowing any account to \`borrow()\` a reference to the Vault to make a \`deposit()\`. Since only the unentitled functions defined under the [\`FungibleToken.Vault\`] interface are exposed, the borrower of the vault reference cannot call \`withdraw()\`, since the method requires a \`Withdraw\` entitled reference on the underlying vault.

Accounts can share private capabilities, but must be specifically issued by the authorizing account. After [issuing], they can be obtained from authorized account objects (\`Account\`) but not public accounts (\`PublicAccount\`). To share a private capability with another account, the owning account must \`publish\` it to another account, which places it in the [account inbox] (not to be mistaken with \`capabilities publish\`). The recipient can later claim the capability from the account inbox using the \`claim\` function.

Public Capabilities can be \`unpublished\` and any capability can also be [revoked] by the creating account.

To aid automation, events are emitted for completed \`publish\`, \`claim\`, and \`unpublish\` actions for a Capability.

Detailed information can be found in [Capabilities].

Hygiene factors for protecting value [#hygiene-factors-for-protecting-value]

While capabilities grant account access to a protected resource, it's still necessary to impose controls on the value accessed through them. For example, if your use case requires delegating access to a \`FlowToken.Vault\` to \`withdraw()\` funds, it's important to limit the amount. Tokens implementing FT/NFT standards are the primary type of value being exchanged by accounts on Flow. The standard provides the primitives needed to implement capability-limiting best practices.

**Token isolation**

All FTs reside in a \`Vault\` resource, and each different FT will exist as a separate \`Vault\` in an account. Similarly, all NFTs implement a \`Collection\` resource, in which those NFTs held by an account for that collection are stored.

Whenever access to the \`withdraw()\` function has to be delegated to another account, the simplest way to limit how many tokens of a given type can be withdrawn is to create a new \`Vault\` resource for that token type and move a smaller amount of the tokens in the main token \`Vault\`. A capability is then linked to that \`Vault\` instance before being made available to another account.

A similar pattern can be used for NFTs, where a new \`Collection\` resource can be created into which only those NFTs that should be exposed are moved. A capability is then linked to that \`Collection\` instance before being made available to another account.

**Bespoke control strategies**

For more complex use cases, you can create a new resource that implements the relevant interfaces to match those of the protected resource(s) that it wraps. The code for the new resource can then enforce limits as required and control how and when a delegation to the underlying resource occurs. One such example is the community-developed [\`ScopedFTProviders\`] and [\`ScoptedNFTProviders\`] utility contracts.

Admin roles [#admin-roles]

Compared to Solidity, creating an admin role in Cadence requires a little more code, all of which is encapsulated within a resource. The admin object design can be highly customized and employ capabilities and [entitlements] for fine-grained control, such as limiting access to individual functions, on a per-account basis if required. The complexity needed for admin roles may vary — for example, larger organizations may require more complex role-based-access schemes. The use of a resource in this context is key — the instance can't be copied, and the account with the first edition mint of the admin serves as the root admin. The admin can be implemented to mint additional admin resource instances, which only the root-admin can grant to selected user accounts via a capability. Conveniently, because the admin role is only accessible via a capability, it's easy to manage with [Capability Revocation].

The admin role originates from the [init singleton pattern] and uses the [Capability Bootstrapping] pattern for making the Capability available to other accounts.

An example admin role implementation is available in the [Cadence cookbook].

Role-based access [#role-based-access]

Implementing role-based access can be achieved by defining roles as resources managed by the root-admin account. Roles can provide limited access to functions, which guard other protected resources that include access levels and/or what is exposed, varying from role to role. The root admin can grant accounts access to individual roles through a private capability. Functions that the roles are permitted to invoke may be scoped as \`access(contract)\` to enforce that they can only be called by code paths in the root-admin contract.

Other best practices and conventions [#other-best-practices-and-conventions]

Certain well-established best practices for Solidity may not apply or are handled differently.

Check effects interactions [#check-effects-interactions]

Solidity contracts must use the [check effect interaction] because functions are public by default and address-based access means that guards must exist when program flow concedes control to an external contract. There are two reasons why this is significantly less of a problem in Cadence. Functions are private by default, and the language provides a range of [access scopes]. More importantly, *risks associated with ceding control to an external contract* is an Ethereum phenomenon; the risk no longer applies. This is primarily because Cadence contracts are not static singletons, so control is never lost to another contract during the scope of a transaction.

Guard check [#guard-check]

Solidity uses \`revert\`, \`require\`, and \`assert\` to validate inputs. \`require\` is a product of the address-based nature of Solidity, which capabilities replace. \`revert\` is similar to Cadence's \`panic\` in that a transaction is aborted. Cadence provides an \`assert\` operator, which mirrors \`assert\` in Solidity.

Modifiers [#modifiers]

Modifiers are extensively used in Solidity when enforcing pre-checks within a function. This is a powerful language feature. However, modifiers can also mutate a state, which introduces risks to the program control flow.

Cadence uses \`pre\` and \`post\` blocks to validate input values or the function execution outputs. Notably, a \`pre\` and \`post\` block prohibits the changing of a state and may only enforce conditions.

Another difference is that modifiers in Solidity can be reused within the contract multiple times. Cadence \`pre\` and \`post\` blocks are associated with individual functions only, reducing the likelihood of errors but resulting in a small amount of code duplication.

Error handling [#error-handling]

Solidity offers a try/catch block to handle errors; however, there is presently no equivalent in Cadence.

Integration differences [#integration-differences]

There are a few notable integration differences between Cadence and Solidity, which are described in the following sections.

Contract imports and dynamic contract borrowing [#contract-imports-and-dynamic-contract-borrowing]

Contracts in Ethereum are similar to static singletons in that interactions happen directly between users and the functions declared on the contract instance itself. The object-oriented nature of Cadence means that contracts are more accurately viewed as imported dependencies. The imported contract makes its object graph available for the code at runtime. Rather than interacting with a contract singleton instance, account interactions to access capabilities are the primary integration entry point, allowing the user to interact with the returned objects.

Dynamic borrowing of a contract inlines the loading of a contract based on its contract address. The loaded contract can be cast to the contract standard interface to which it conforms to (e.g., NFT standard) and then interacted with in the same way if it were statically imported. Consider the implications of this for the composability of contracts.

Detailed information about deploying, updating, removing, or borrowing contracts can be found in [Contracts].

Multi-key, multi-signature support [#multi-key-multi-signature-support]

Solidity supports only one kind of multi-signature scheme where \`n\` out of \`m\` (assuming \`m >= n\`) approvals need to be obtained to execute the transaction from the multi-signature smart contract. The most used multi-signature smart contract in the Ethereum ecosystem is the Gnosis [safe contract]. However, Solidity lacks support for signature aggregation or BLS signature schemes.

Cadence offers a wide range of options to implement various multi-signature schemes, including:

* Inherent support for multi-sign transactions.
* Resource transfer scheme.
* Inherent support of the BLS signature scheme.

Flow account keys have assigned weights, where a 1000 unit weight is the cumulative weight needed from signing keys to execute a transaction successfully. One can divide weights arbitrarily across multiple keys and distribute those partial weighted keys to authorized signers. When signing the transaction, all signers must sign the transaction together in a short period of time in order for the cumulative weight to reach 1000 units.

See the [BLS Signature scheme] for a detailed overview of the inherent support of BLS signatures.

**Resource transfer scheme**

The main limitation of multi-signature transactions is that signatures must all be made for the transaction within a relatively short time window. If this window is missed, the transaction will abort. The resource transfer scheme is very similar to the Solidity multi-signature smart contract. A resource is created that has the functionality to proxy the execution of a fund transfer. This resource is handed from one signer to the next to collect signatures. Once the threshold of required signatures is met, the transaction is executed. The main drawback with this approach is that it does not support the execution of arbitrary functionality.

Other platform differences [#other-platform-differences]

The following differences, which are unrelated to implementing Cadence contracts, are useful to understand in the context of application design.

Events [#events]

Flow uses [events] extensively to provide real-time signals to offchain systems about particular actions that occurred during a transaction. The main difference in Flow is that events remain part of the history and are not purged from storage. Events can be populated with arbitrary data that will assist consumers of the event. Builders are encouraged to leverage events for seamless UX as users perform transactions.

Contract upgradeability [#contract-upgradeability]

Flow supports limited upgradability of Cadence contracts, which is most helpful during development. The following function shows how an account owner can update a contract:

\`\`\`solidity
fun update(name: String, code: [UInt8]): DeployedContract
\`\`\`

Upgrades are analyzed for prohibited changes once uploaded for an upgrade. Upgradeability is still an early-phase feature, which will continue to improve over time.

To enforce immutability once a contract is tested and ready to deploy, account owners can optionally revoke keys from the account containing the contract.

Detailed information about the cadence upgradeability is available in [Contract Updatability].

Account key formulation [#account-key-formulation]

In EVM-based chains, an address is derived from a cryptographically generated public key and can have a single private key, supporting one type of signature curve (i.e., ECDSA). They are not verifiable offchain and typos/truncation in an address may result in funds being lost.

Flow account addresses have a special format and are verifiable offchain. Verifying address format validity can be done using an error detection algorithm based on linear code. While this does not also confirm that an address is active onchain, the extra verifiability is a useful safeguard.

Contract size constraints [#contract-size-constraints]

Solidity developers will be well aware of the [EIP-170] deployable contract bytecode size limit of 24KB. This can burden builders who need to optimize contract bytecode size, sometimes even requiring a re-design of contracts to break it into smaller contract parts.

By contrast, Cadence has no inherent or defined smart contract size limit. However, it is restricted by the transaction size limit, which is 1.5MB. With very rare exceptions, it's unlikely that this limit would pose a problem to those developing Cadence contracts. Should it be needed, there is a known way to deploy a contract exceeding 1.5MB, which we will document at a later time.

Low-level language differences [#low-level-language-differences]

There are several language differences between Solidity and Cadence, which are described in the following sections.

Arithmetic [#arithmetic]

Historically, Solidity, smart contracts lost millions of dollars because of improper handling of arithmetic under/overflows. Contemporary Solidity versions offer inbuilt handling of under/overflow for arithmetic operations.

Cadence implements [saturating math], which avoids overflow/underflow.

Optional support [#optional-support]

[Optional binding] provides built-in conditional handling of nil values. Regular data types in Cadence must always have a value and cannot be nil. Optionals enable variables or constants that might contain a certain type or a nil value. Optional bindings have two cases: either there is a value or there is nothing — they fork program flow similar to \`if nil; else; end;\`.

Iterable dictionaries [#iterable-dictionaries]

Solidity offers the mapping type, however it is not iterable. Because of that, dapp developers have to maintain offchain tracking to have access to keys. This also pushes builders to create custom data types like \`EnumerableMap\`, which adds to gas costs.

Cadence offers the [Dictionary] type, an unordered collection of key-value associations, which is iterable.

Rich support for type utility functions [#rich-support-for-type-utility-functions]

Cadence offers numerous native-type utility functions to simplify development. For example, the String type provides:

* \`utf8\`
* \`length\`
* \`concat()\`
* \`slice()\`
* \`split()\`
* \`replaceAll()\`
* \`join()\`
* \`decodeHex()\`
* \`encodeHex()\`
* \`fromCharacters()\`
* \`fromUTF8()\`
* \`toLower()\`

Argument labelling [#argument-labelling]

Argument labels in Cadence help to disambiguate input values. They make code more readable and explicit. They also eliminate confusion around the order of arguments when working with the same type. They must be included in the function call, but this restriction can be skipped if the label is preceded by \`_ \` on its declaration.

For example:

* if \`fun foo(balance: UFix64)\`, which is called as \`self.foo(balance: 30.0)\`
* then, \`fun foo( _balance: UFix64)\` can be called as \`self.foo(balance: 30.0)\` or as \`self.foo(30.0)\`.

One thing to note about argument labelling is that function overloading is not currently supported in Cadence. This means that functions with the same name but different argument labels are not allowed, which is an available feature in Solidity.

Additional resources [#additional-resources]

* [On-Chain Token Transfer Deep Dive] — Cadence or Solidity
* [Bored Ape Yacht Club] — Implementing a smart contract in Cadence
* [Comparing AA on Ethereum vs Flow] — Quicknode's account abstraction on the Flow blockchain

{/* Relative links. Will not render on the page */}

[Resources]: ./language/resources

[\`FungibleToken.Vault\`]: https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc#L167

[\`ScopedFTProviders\`]: https://github.com/green-goo-dao/flow-utils/blob/main/contracts/ScopedFTProviders.cdc

[\`ScoptedNFTProviders\`]: https://github.com/green-goo-dao/flow-utils/blob/main/contracts/ScopedNFTProviders.cdc

[access scopes]: ./language/access-control

[access-based security]: https://en.wikipedia.org/wiki/Access-control_list

[account inbox]: ./language/accounts/inbox

[BLS Signature scheme]: ./language/crypto#bls-multi-signature

[Bored Ape Yacht Club]: https://flow.com/post/implementing-the-bored-ape-yacht-club-smart-contract-in-cadence

[Cadence cookbook]: https://cookbook.onflow.org/?preview=13

[Capabilities]: ./language/capabilities

[Capability Bootstrapping]: ./design-patterns#capability-bootstrapping

[Capability Revocation]: ./design-patterns#capability-revocation

[capability-based security]: https://en.wikipedia.org/wiki/Capability-based_security

[case study]: https://flow.com/post/flovatar-nft-flow-blockchain-case-study

[Cross-VM Bridge]: https://developers.flow.com/tutorials/cross-vm-apps/vm-bridge

[check effect interaction]: https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html

[Comparing AA on Ethereum vs Flow]: https://www.quicknode.com/guides/other-chains/flow/account-abstraction-on-flow#account-abstraction-on-ethereum-vs-flow

[Contract Updatability]: ./language/contract-updatability

[Contracts]: ./language/contracts

[Dictionary]: ./language/control-flow

[EIP-170]: https://eips.ethereum.org/EIPS/eip-170

[entitlements]: ./language/access-control#entitlements

[events]: ./language/events

[Flow account model]: https://developers.flow.com/build/basics/accounts.md

[Flow NFT Catalog]: https://www.flow-nft-catalog.com/

[Fungible Token]: https://developers.flow.com/build/flow.md#flow-token

[init singleton pattern]: ./design-patterns#init-singleton

[Introduction to Flow]: https://developers.flow.com/build/flow.md

[issuing]: ./language/accounts/capabilities#issuing-capabilities

[linear types]: https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems

[multi-sig]: #multi-key-multi-signature-support

[Non-Fungible Token]: https://developers.flow.com/build/flow.md#overview

[On-Chain Token Transfer Deep Dive]: https://flow.com/engineering-blogs/flow-blockchain-programming-language-smart-contract-cadence-solidity-comparison-ethereum

[Optional binding]: ./language/control-flow#optional-binding

[queries]: https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_balance.cdc

[revoked]: ./design-patterns#capability-revocation

[safe contract]: https://github.com/safe-global/safe-contracts/blob/main/contracts/Safe.sol

[saturating math]: https://en.wikipedia.org/wiki/Saturation_arithmetic

[Transactions]: https://github.com/onflow/flow-ft/tree/master/transactions

[unentitled]: ./language/access-control#entitlements

[utility views]: https://developers.flow.com/build/flow.md

[views]: https://developers.flow.com/build/flow.md
`,d={title:"Cadence Guide for Solidity Developers"},h={contents:[{heading:void 0,content:"Cadence introduces a different way to approach smart contract development, which may feel unfamiliar to Solidity developers. There are fundamental mindset and platform differences, and also several new language features that have no real equivalent in Solidity. As a result, while you can make similar programs in Cadence as you could in Solidity, a direct translation from one to the other isn't possible - similar to how you could make a note-taking app in C or in JavaScript, but it wouldn't be possible to directly translate the C code into JavaScript. You'd have to write an entirely new program for a new paradigm."},{heading:void 0,content:"This guide outlines high level design and conceptual aspects of Flow and Cadence that are essential to understand, platform and integration differences, as well as detailed guidance on how to perform certain common Solidity development tasks using Cadence idioms. We also provide details on how to best leverage Cadence's unique features and how to avoid common pitfalls that may come up while transitioning."},{heading:"conceptual-foundations-for-cadence",content:"A fundamental difference to get used to when adjusting to Cadence from Solidity is **mindset**. Security and interoperability on Ethereum are designed around addresses (or more specifically, the account associated with an address), resulting in all contracts having to carefully track and evaluate access and authorizations."},{heading:"conceptual-foundations-for-cadence",content:"Transactions are based on who authorized them, which is provided as `msg.sender` in the transaction context. User-to-contract, or contract-to-contract interactions, must be explicitly coded **in the contract and in advance** to ensure the appropriate approvals have been made before interacting with a contract. The contract-based nature of storage means that user ownership in Ethereum is represented in a mapping (e.g., from owner to balance or token ID to owner). Put another way, ownership is tracked in ledger records similar to a person's bank balance. Crypto wallets help combine balances from multiple token types into a convenient view for the user."},{heading:"conceptual-foundations-for-cadence",content:"Cadence introduces new primitives and distinct functionalities, namely [Resources] and [Capabilities], that are designed around Flow's account model. Resources are first-class language types, which are unique, non-copyable, and cannot be discarded. These properties make resources ideal for representing digital assets like currency or tokens that are always limited in number. Resources are always stored in account storage, and contracts control access to them using capabilities. Capabilities are another special type that secures protected resources without the need for tracking addresses. Cadence makes working with these straightforward and intuitive to those familiar with object-oriented programming languages."},{heading:"scripts-and-transactions",content:"One of the most important (and powerful!) difference between Cadence and Solidity is that deployed contracts are not the only code being executed in the VM. Cadence offers scripts and transactions, which are written in Cadence and always exist offchain. However, they are the top-level code payload being executed by the execution runtime. Clients send scripts and transactions through the Flow Access API gRPC or REST endpoints, returning results to clients when applicable."},{heading:"scripts-and-transactions",content:"Scripts and transactions enable more efficient and powerful ways to integrate dapps with the underlying blockchain, where contracts can more purely be thought of as services or components, with scripts or transactions becoming the dapp-specific API interface for chain interactions."},{heading:"scripts-and-transactions",content:"What this means is that you **don't have to predict the future** when writing your contracts and your **views aren't limited to functions in the contract**. Even more importantly, you can **write transactions that call multiple functions with multiple deployed contracts that you don't need to own** and are signed with one signature."},{heading:"scripts-and-transactions",content:"Scripts are read-only in nature, requiring only a `main` function declaration that performs [queries] against a chain state. For example:"},{heading:"scripts-and-transactions",content:"[Transactions] are an Atomic, Consistent, Isolated, and Durable (ACID) version of scripts having only `prepare` and `execute` functions that either succeed in full and mutate the chain state as described, or otherwise fail and mutate nothing. They also support a setting of `pre` and `post` conditions. In the following transaction example, `ExampleToken`s are deposited into multiple `receiver` vaults for each address in the input map:"},{heading:"scripts-and-transactions",content:"Transactions can encompass an arbitrary number of withdrawals/deposits across multiple FTs, sending to multiple addresses or other more complex variations, all of which will succeed or fail in their entirety given their ACID properties."},{heading:"flow-account-model",content:`The [Flow account model] in Cadence combines storage for the keys and code ("smart contracts") associated with an account with storage for the assets owned by that account. That's right — in Cadence, your tokens are stored in your account, and not in a smart contract. Of course, smart contracts still define these assets and how they behave, but those assets can be securely stored in a user's account through the magic of Resources:`},{heading:"flow-account-model",content:"There is only one account type in Cadence that uses an account address, similar to an Externally-Owned-Account (EOA) address in Ethereum. Unlike Ethereum contracts, Cadence accounts directly store contract code. Accounts realize ownership on Flow by being the container where keys, resources, and contracts are stored onchain."},{heading:"account",content:"`Account` is the type that provides access to an account."},{heading:"account",content:"The `getAccount` function allows you to get access to the publicly available functions and fields of an account. For example, this allows querying an account's balance."},{heading:"account",content:"An authorized `Account` reference provides access and allows the management of the account's storage, key configuration, and contract code. An authorized `Account` reference can only be acquired by signing a transaction. Capabilities ensure that resources held in an account can be safely shared and accessed."},{heading:"resources",content:"Resources are unique, [linear types] that can never be copied or implicitly discarded, and can only be moved between accounts. Static checks during development flag an error for a failure to store a resource moved from an account if that resource is not appropriately moved back into storage for a same or new account, or explicitly destroyed. The run-time enforces the same strict rules in terms of allowed operations. Therefore, contract functions that do not properly handle resources in scope before exiting will abort, reverting the resource to the original storage. These features of resources make them perfect for representing tokens, both fungible and non-fungible. Ownership is tracked by where they are stored, and the assets can't be duplicated or accidentally lost since the language itself enforces correctness."},{heading:"resources",content:"Flow encourages the storage of data and compute onchain and resource-types makes this easier than ever. Since resources are always stored in accounts, any data and code that exists in resource instances is seamlessly managed onchain without any explicit handling needed."},{heading:"capability-based-access",content:`Remote access to stored objects is managed via [Capabilities]. This means that if an account wants to be able to access another account's stored objects, it must have been provided with a valid capability to that object. Capabilities can be either public or private. An account can share a public capability if it wants to give all other accounts access. For example, it's common for an account to accept fungible token deposits from all sources via a public capability. Alternatively, an account can grant private capabilities to specific accounts in order to provide access to restricted functionality. For example, a non-fungible token (NFT) project often controls minting through an "administrator capability" that grants specific accounts the power to mint new tokens.`},{heading:"contract-standards",content:"There are numerous widely-used contract standards established to benefit the ecosystem. For example, [Fungible Token] (FT) and [Non-Fungible Token] (NFT) are standards that are conceptually equivalent to Ethereum's ERC-20 and ERC-721 standards. Cadence's object-oriented design means standards apply through contract sub-types such as resources, resource interfaces, or other types declared in the contract standard. Standards can define and limit behavior and/or set conditions that implementations of the standard cannot violate."},{heading:"contract-standards",content:"Detailed information about available standards and other core contracts can be found in the [Introduction to Flow]."},{heading:"nft-standard-and-metadata",content:"Solidity must manage NFT metadata offchain, and NFTs frequently link to IPFS-hosted JSON from onchain."},{heading:"nft-standard-and-metadata",content:"The Cadence NFT standard provides built-in support for metadata with specific types called [views]. Views can be added to NFTs when minted and will always be available as part of the NFT. While metadata is stored onchain, graphics and video content are stored offchain. Cadence provides [utility views] for both HTTP- and IPFS-based media storage, which remain linked to your NFT."},{heading:"nft-standard-and-metadata",content:"Using NFT metadata views is a requirement to get listed in the [Flow NFT Catalog]. Projects are encouraged to leverage the NFT catalog since wallets and other ecosystem partners can seamlessly integrate new collections added there with no input from project creators."},{heading:"nft-standard-and-metadata",content:"NFT metadata on Flow opens the door to exciting new possibilities that help builders innovate. Check out this recent [case study] where a community partner leveraged SVG-based metadata to make combined 2D + 3D versions of their PFPs, all onchain inside the NFTs' metadata!"},{heading:"nft-standard-and-metadata",content:"Under most circumstances, NFTs bridged via the [Cross-VM Bridge] from Flow Cadence to Flow EVM will automatically be provided with"},{heading:"security-and-access-control",content:"Decentralized application development places significant focus on security and access, which can fairly be described as security engineering. Understanding how resources, capabilities, and the account model solve this may not be obvious when viewed from a Solidity perspective."},{heading:"msgsender-considered-harmful",content:"The first question that every Solidity developer asks when they start programming in Cadence is:"},{heading:"msgsender-considered-harmful",content:"***How do I get the account that authorized the transaction?***"},{heading:"msgsender-considered-harmful",content:"In Ethereum, this account is referred to as `msg.sender` and it informs the program flow in a function depending on who authorized it. Doing so is key to access and security, and is the basis of identity and ownership on Ethereum."},{heading:"msgsender-considered-harmful",content:"Cadence does not support `msg.sender`, and there is no transaction-level way for Cadence code to uniquely identify the calling account. Even if there was a way to access it, Cadence supports [multi-sig] transactions, meaning that a list of all the signers' accounts would be returned, making it impossible to identify a single authorizer."},{heading:"msgsender-considered-harmful",content:"The reason `msg.sender` is both unsupported and strongly advised against is that Cadence uses capabilities for access rather than addresses. The mindset change that developers need to adjust to is that a capability must first be obtained by the authorizing account (called the provider or signer in Cadence) from the contract that will require it, which then enables the requesting account to access the protected function or resource. This means the contract never needs to know who the signer is before proceeding because the capability **IS** the authorization."},{heading:"msgsender-considered-harmful",content:"In EVM, the contract grants access to an address or addresses, thus it must know and operate based on the address of the signer:"},{heading:"msgsender-considered-harmful",content:"The [capability-based security] model of Cadence frames access in the opposite direction from the [access-based security] model. Accounts are granted and store the capability to access and use functionality on the contract:"},{heading:"access-control-using-capabilities",content:"Solidity lacks specific types or other primitives to aid with permission management. Developers must inline guards to `require` at every function entry point, thus validating the `msg.sender` of the transaction."},{heading:"access-control-using-capabilities",content:"[Capabilities] are defined by linking storage paths (namespaces for contract storage) to protected objects and then making that linked capability available to other accounts."},{heading:"access-control-using-capabilities",content:"Any account can get access to an account's public capabilities. Public capabilities are created using public paths (i.e., they have the domain `public`). For example, all accounts have a default public capability linked to the `FlowToken.Vault` resource. This vault is exposed as a public [unentitled] capability, allowing any account to `borrow()` a reference to the Vault to make a `deposit()`. Since only the unentitled functions defined under the [`FungibleToken.Vault`] interface are exposed, the borrower of the vault reference cannot call `withdraw()`, since the method requires a `Withdraw` entitled reference on the underlying vault."},{heading:"access-control-using-capabilities",content:"Accounts can share private capabilities, but must be specifically issued by the authorizing account. After [issuing], they can be obtained from authorized account objects (`Account`) but not public accounts (`PublicAccount`). To share a private capability with another account, the owning account must `publish` it to another account, which places it in the [account inbox] (not to be mistaken with `capabilities publish`). The recipient can later claim the capability from the account inbox using the `claim` function."},{heading:"access-control-using-capabilities",content:"Public Capabilities can be `unpublished` and any capability can also be [revoked] by the creating account."},{heading:"access-control-using-capabilities",content:"To aid automation, events are emitted for completed `publish`, `claim`, and `unpublish` actions for a Capability."},{heading:"access-control-using-capabilities",content:"Detailed information can be found in [Capabilities]."},{heading:"hygiene-factors-for-protecting-value",content:"While capabilities grant account access to a protected resource, it's still necessary to impose controls on the value accessed through them. For example, if your use case requires delegating access to a `FlowToken.Vault` to `withdraw()` funds, it's important to limit the amount. Tokens implementing FT/NFT standards are the primary type of value being exchanged by accounts on Flow. The standard provides the primitives needed to implement capability-limiting best practices."},{heading:"hygiene-factors-for-protecting-value",content:"**Token isolation**"},{heading:"hygiene-factors-for-protecting-value",content:"All FTs reside in a `Vault` resource, and each different FT will exist as a separate `Vault` in an account. Similarly, all NFTs implement a `Collection` resource, in which those NFTs held by an account for that collection are stored."},{heading:"hygiene-factors-for-protecting-value",content:"Whenever access to the `withdraw()` function has to be delegated to another account, the simplest way to limit how many tokens of a given type can be withdrawn is to create a new `Vault` resource for that token type and move a smaller amount of the tokens in the main token `Vault`. A capability is then linked to that `Vault` instance before being made available to another account."},{heading:"hygiene-factors-for-protecting-value",content:"A similar pattern can be used for NFTs, where a new `Collection` resource can be created into which only those NFTs that should be exposed are moved. A capability is then linked to that `Collection` instance before being made available to another account."},{heading:"hygiene-factors-for-protecting-value",content:"**Bespoke control strategies**"},{heading:"hygiene-factors-for-protecting-value",content:"For more complex use cases, you can create a new resource that implements the relevant interfaces to match those of the protected resource(s) that it wraps. The code for the new resource can then enforce limits as required and control how and when a delegation to the underlying resource occurs. One such example is the community-developed [`ScopedFTProviders`] and [`ScoptedNFTProviders`] utility contracts."},{heading:"admin-roles",content:"Compared to Solidity, creating an admin role in Cadence requires a little more code, all of which is encapsulated within a resource. The admin object design can be highly customized and employ capabilities and [entitlements] for fine-grained control, such as limiting access to individual functions, on a per-account basis if required. The complexity needed for admin roles may vary — for example, larger organizations may require more complex role-based-access schemes. The use of a resource in this context is key — the instance can't be copied, and the account with the first edition mint of the admin serves as the root admin. The admin can be implemented to mint additional admin resource instances, which only the root-admin can grant to selected user accounts via a capability. Conveniently, because the admin role is only accessible via a capability, it's easy to manage with [Capability Revocation]."},{heading:"admin-roles",content:"The admin role originates from the [init singleton pattern] and uses the [Capability Bootstrapping] pattern for making the Capability available to other accounts."},{heading:"admin-roles",content:"An example admin role implementation is available in the [Cadence cookbook]."},{heading:"role-based-access",content:"Implementing role-based access can be achieved by defining roles as resources managed by the root-admin account. Roles can provide limited access to functions, which guard other protected resources that include access levels and/or what is exposed, varying from role to role. The root admin can grant accounts access to individual roles through a private capability. Functions that the roles are permitted to invoke may be scoped as `access(contract)` to enforce that they can only be called by code paths in the root-admin contract."},{heading:"other-best-practices-and-conventions",content:"Certain well-established best practices for Solidity may not apply or are handled differently."},{heading:"check-effects-interactions",content:"Solidity contracts must use the [check effect interaction] because functions are public by default and address-based access means that guards must exist when program flow concedes control to an external contract. There are two reasons why this is significantly less of a problem in Cadence. Functions are private by default, and the language provides a range of [access scopes]. More importantly, *risks associated with ceding control to an external contract* is an Ethereum phenomenon; the risk no longer applies. This is primarily because Cadence contracts are not static singletons, so control is never lost to another contract during the scope of a transaction."},{heading:"guard-check",content:"Solidity uses `revert`, `require`, and `assert` to validate inputs. `require` is a product of the address-based nature of Solidity, which capabilities replace. `revert` is similar to Cadence's `panic` in that a transaction is aborted. Cadence provides an `assert` operator, which mirrors `assert` in Solidity."},{heading:"modifiers",content:"Modifiers are extensively used in Solidity when enforcing pre-checks within a function. This is a powerful language feature. However, modifiers can also mutate a state, which introduces risks to the program control flow."},{heading:"modifiers",content:"Cadence uses `pre` and `post` blocks to validate input values or the function execution outputs. Notably, a `pre` and `post` block prohibits the changing of a state and may only enforce conditions."},{heading:"modifiers",content:"Another difference is that modifiers in Solidity can be reused within the contract multiple times. Cadence `pre` and `post` blocks are associated with individual functions only, reducing the likelihood of errors but resulting in a small amount of code duplication."},{heading:"error-handling",content:"Solidity offers a try/catch block to handle errors; however, there is presently no equivalent in Cadence."},{heading:"integration-differences",content:"There are a few notable integration differences between Cadence and Solidity, which are described in the following sections."},{heading:"contract-imports-and-dynamic-contract-borrowing",content:"Contracts in Ethereum are similar to static singletons in that interactions happen directly between users and the functions declared on the contract instance itself. The object-oriented nature of Cadence means that contracts are more accurately viewed as imported dependencies. The imported contract makes its object graph available for the code at runtime. Rather than interacting with a contract singleton instance, account interactions to access capabilities are the primary integration entry point, allowing the user to interact with the returned objects."},{heading:"contract-imports-and-dynamic-contract-borrowing",content:"Dynamic borrowing of a contract inlines the loading of a contract based on its contract address. The loaded contract can be cast to the contract standard interface to which it conforms to (e.g., NFT standard) and then interacted with in the same way if it were statically imported. Consider the implications of this for the composability of contracts."},{heading:"contract-imports-and-dynamic-contract-borrowing",content:"Detailed information about deploying, updating, removing, or borrowing contracts can be found in [Contracts]."},{heading:"multi-key-multi-signature-support",content:"Solidity supports only one kind of multi-signature scheme where `n` out of `m` (assuming `m >= n`) approvals need to be obtained to execute the transaction from the multi-signature smart contract. The most used multi-signature smart contract in the Ethereum ecosystem is the Gnosis [safe contract]. However, Solidity lacks support for signature aggregation or BLS signature schemes."},{heading:"multi-key-multi-signature-support",content:"Cadence offers a wide range of options to implement various multi-signature schemes, including:"},{heading:"multi-key-multi-signature-support",content:"Inherent support for multi-sign transactions."},{heading:"multi-key-multi-signature-support",content:"Resource transfer scheme."},{heading:"multi-key-multi-signature-support",content:"Inherent support of the BLS signature scheme."},{heading:"multi-key-multi-signature-support",content:"Flow account keys have assigned weights, where a 1000 unit weight is the cumulative weight needed from signing keys to execute a transaction successfully. One can divide weights arbitrarily across multiple keys and distribute those partial weighted keys to authorized signers. When signing the transaction, all signers must sign the transaction together in a short period of time in order for the cumulative weight to reach 1000 units."},{heading:"multi-key-multi-signature-support",content:"See the [BLS Signature scheme] for a detailed overview of the inherent support of BLS signatures."},{heading:"multi-key-multi-signature-support",content:"**Resource transfer scheme**"},{heading:"multi-key-multi-signature-support",content:"The main limitation of multi-signature transactions is that signatures must all be made for the transaction within a relatively short time window. If this window is missed, the transaction will abort. The resource transfer scheme is very similar to the Solidity multi-signature smart contract. A resource is created that has the functionality to proxy the execution of a fund transfer. This resource is handed from one signer to the next to collect signatures. Once the threshold of required signatures is met, the transaction is executed. The main drawback with this approach is that it does not support the execution of arbitrary functionality."},{heading:"other-platform-differences",content:"The following differences, which are unrelated to implementing Cadence contracts, are useful to understand in the context of application design."},{heading:"events",content:"Flow uses [events] extensively to provide real-time signals to offchain systems about particular actions that occurred during a transaction. The main difference in Flow is that events remain part of the history and are not purged from storage. Events can be populated with arbitrary data that will assist consumers of the event. Builders are encouraged to leverage events for seamless UX as users perform transactions."},{heading:"contract-upgradeability",content:"Flow supports limited upgradability of Cadence contracts, which is most helpful during development. The following function shows how an account owner can update a contract:"},{heading:"contract-upgradeability",content:"Upgrades are analyzed for prohibited changes once uploaded for an upgrade. Upgradeability is still an early-phase feature, which will continue to improve over time."},{heading:"contract-upgradeability",content:"To enforce immutability once a contract is tested and ready to deploy, account owners can optionally revoke keys from the account containing the contract."},{heading:"contract-upgradeability",content:"Detailed information about the cadence upgradeability is available in [Contract Updatability]."},{heading:"account-key-formulation",content:"In EVM-based chains, an address is derived from a cryptographically generated public key and can have a single private key, supporting one type of signature curve (i.e., ECDSA). They are not verifiable offchain and typos/truncation in an address may result in funds being lost."},{heading:"account-key-formulation",content:"Flow account addresses have a special format and are verifiable offchain. Verifying address format validity can be done using an error detection algorithm based on linear code. While this does not also confirm that an address is active onchain, the extra verifiability is a useful safeguard."},{heading:"contract-size-constraints",content:"Solidity developers will be well aware of the [EIP-170] deployable contract bytecode size limit of 24KB. This can burden builders who need to optimize contract bytecode size, sometimes even requiring a re-design of contracts to break it into smaller contract parts."},{heading:"contract-size-constraints",content:"By contrast, Cadence has no inherent or defined smart contract size limit. However, it is restricted by the transaction size limit, which is 1.5MB. With very rare exceptions, it's unlikely that this limit would pose a problem to those developing Cadence contracts. Should it be needed, there is a known way to deploy a contract exceeding 1.5MB, which we will document at a later time."},{heading:"low-level-language-differences",content:"There are several language differences between Solidity and Cadence, which are described in the following sections."},{heading:"arithmetic",content:"Historically, Solidity, smart contracts lost millions of dollars because of improper handling of arithmetic under/overflows. Contemporary Solidity versions offer inbuilt handling of under/overflow for arithmetic operations."},{heading:"arithmetic",content:"Cadence implements [saturating math], which avoids overflow/underflow."},{heading:"optional-support",content:"[Optional binding] provides built-in conditional handling of nil values. Regular data types in Cadence must always have a value and cannot be nil. Optionals enable variables or constants that might contain a certain type or a nil value. Optional bindings have two cases: either there is a value or there is nothing — they fork program flow similar to `if nil; else; end;`."},{heading:"iterable-dictionaries",content:"Solidity offers the mapping type, however it is not iterable. Because of that, dapp developers have to maintain offchain tracking to have access to keys. This also pushes builders to create custom data types like `EnumerableMap`, which adds to gas costs."},{heading:"iterable-dictionaries",content:"Cadence offers the [Dictionary] type, an unordered collection of key-value associations, which is iterable."},{heading:"rich-support-for-type-utility-functions",content:"Cadence offers numerous native-type utility functions to simplify development. For example, the String type provides:"},{heading:"rich-support-for-type-utility-functions",content:"`utf8`"},{heading:"rich-support-for-type-utility-functions",content:"`length`"},{heading:"rich-support-for-type-utility-functions",content:"`concat()`"},{heading:"rich-support-for-type-utility-functions",content:"`slice()`"},{heading:"rich-support-for-type-utility-functions",content:"`split()`"},{heading:"rich-support-for-type-utility-functions",content:"`replaceAll()`"},{heading:"rich-support-for-type-utility-functions",content:"`join()`"},{heading:"rich-support-for-type-utility-functions",content:"`decodeHex()`"},{heading:"rich-support-for-type-utility-functions",content:"`encodeHex()`"},{heading:"rich-support-for-type-utility-functions",content:"`fromCharacters()`"},{heading:"rich-support-for-type-utility-functions",content:"`fromUTF8()`"},{heading:"rich-support-for-type-utility-functions",content:"`toLower()`"},{heading:"argument-labelling",content:"Argument labels in Cadence help to disambiguate input values. They make code more readable and explicit. They also eliminate confusion around the order of arguments when working with the same type. They must be included in the function call, but this restriction can be skipped if the label is preceded by `_ ` on its declaration."},{heading:"argument-labelling",content:"For example:"},{heading:"argument-labelling",content:"if `fun foo(balance: UFix64)`, which is called as `self.foo(balance: 30.0)`"},{heading:"argument-labelling",content:"then, `fun foo( _balance: UFix64)` can be called as `self.foo(balance: 30.0)` or as `self.foo(30.0)`."},{heading:"argument-labelling",content:"One thing to note about argument labelling is that function overloading is not currently supported in Cadence. This means that functions with the same name but different argument labels are not allowed, which is an available feature in Solidity."},{heading:"additional-resources",content:"[On-Chain Token Transfer Deep Dive] — Cadence or Solidity"},{heading:"additional-resources",content:"[Bored Ape Yacht Club] — Implementing a smart contract in Cadence"},{heading:"additional-resources",content:"[Comparing AA on Ethereum vs Flow] — Quicknode's account abstraction on the Flow blockchain"}],headings:[{id:"conceptual-foundations-for-cadence",content:"Conceptual foundations for Cadence"},{id:"scripts-and-transactions",content:"Scripts and transactions"},{id:"flow-account-model",content:"Flow account model"},{id:"account",content:"Account"},{id:"resources",content:"Resources"},{id:"capability-based-access",content:"Capability-based access"},{id:"contract-standards",content:"Contract standards"},{id:"nft-standard-and-metadata",content:"NFT standard and metadata"},{id:"security-and-access-control",content:"Security and access control"},{id:"msgsender-considered-harmful",content:"msg.sender considered harmful"},{id:"access-control-using-capabilities",content:"Access control using capabilities"},{id:"hygiene-factors-for-protecting-value",content:"Hygiene factors for protecting value"},{id:"admin-roles",content:"Admin roles"},{id:"role-based-access",content:"Role-based access"},{id:"other-best-practices-and-conventions",content:"Other best practices and conventions"},{id:"check-effects-interactions",content:"Check effects interactions"},{id:"guard-check",content:"Guard check"},{id:"modifiers",content:"Modifiers"},{id:"error-handling",content:"Error handling"},{id:"integration-differences",content:"Integration differences"},{id:"contract-imports-and-dynamic-contract-borrowing",content:"Contract imports and dynamic contract borrowing"},{id:"multi-key-multi-signature-support",content:"Multi-key, multi-signature support"},{id:"other-platform-differences",content:"Other platform differences"},{id:"events",content:"Events"},{id:"contract-upgradeability",content:"Contract upgradeability"},{id:"account-key-formulation",content:"Account key formulation"},{id:"contract-size-constraints",content:"Contract size constraints"},{id:"low-level-language-differences",content:"Low-level language differences"},{id:"arithmetic",content:"Arithmetic"},{id:"optional-support",content:"Optional support"},{id:"iterable-dictionaries",content:"Iterable dictionaries"},{id:"rich-support-for-type-utility-functions",content:"Rich support for type utility functions"},{id:"argument-labelling",content:"Argument labelling"},{id:"additional-resources",content:"Additional resources"}]};const u=[{depth:2,url:"#conceptual-foundations-for-cadence",title:e.jsx(e.Fragment,{children:"Conceptual foundations for Cadence"})},{depth:3,url:"#scripts-and-transactions",title:e.jsx(e.Fragment,{children:"Scripts and transactions"})},{depth:2,url:"#flow-account-model",title:e.jsx(e.Fragment,{children:"Flow account model"})},{depth:2,url:"#account",title:e.jsx(e.Fragment,{children:"Account"})},{depth:2,url:"#resources",title:e.jsx(e.Fragment,{children:"Resources"})},{depth:2,url:"#capability-based-access",title:e.jsx(e.Fragment,{children:"Capability-based access"})},{depth:2,url:"#contract-standards",title:e.jsx(e.Fragment,{children:"Contract standards"})},{depth:3,url:"#nft-standard-and-metadata",title:e.jsx(e.Fragment,{children:"NFT standard and metadata"})},{depth:2,url:"#security-and-access-control",title:e.jsx(e.Fragment,{children:"Security and access control"})},{depth:3,url:"#msgsender-considered-harmful",title:e.jsx(e.Fragment,{children:"msg.sender considered harmful"})},{depth:3,url:"#access-control-using-capabilities",title:e.jsx(e.Fragment,{children:"Access control using capabilities"})},{depth:3,url:"#hygiene-factors-for-protecting-value",title:e.jsx(e.Fragment,{children:"Hygiene factors for protecting value"})},{depth:3,url:"#admin-roles",title:e.jsx(e.Fragment,{children:"Admin roles"})},{depth:3,url:"#role-based-access",title:e.jsx(e.Fragment,{children:"Role-based access"})},{depth:2,url:"#other-best-practices-and-conventions",title:e.jsx(e.Fragment,{children:"Other best practices and conventions"})},{depth:3,url:"#check-effects-interactions",title:e.jsx(e.Fragment,{children:"Check effects interactions"})},{depth:3,url:"#guard-check",title:e.jsx(e.Fragment,{children:"Guard check"})},{depth:3,url:"#modifiers",title:e.jsx(e.Fragment,{children:"Modifiers"})},{depth:3,url:"#error-handling",title:e.jsx(e.Fragment,{children:"Error handling"})},{depth:2,url:"#integration-differences",title:e.jsx(e.Fragment,{children:"Integration differences"})},{depth:3,url:"#contract-imports-and-dynamic-contract-borrowing",title:e.jsx(e.Fragment,{children:"Contract imports and dynamic contract borrowing"})},{depth:3,url:"#multi-key-multi-signature-support",title:e.jsx(e.Fragment,{children:"Multi-key, multi-signature support"})},{depth:2,url:"#other-platform-differences",title:e.jsx(e.Fragment,{children:"Other platform differences"})},{depth:3,url:"#events",title:e.jsx(e.Fragment,{children:"Events"})},{depth:3,url:"#contract-upgradeability",title:e.jsx(e.Fragment,{children:"Contract upgradeability"})},{depth:3,url:"#account-key-formulation",title:e.jsx(e.Fragment,{children:"Account key formulation"})},{depth:3,url:"#contract-size-constraints",title:e.jsx(e.Fragment,{children:"Contract size constraints"})},{depth:2,url:"#low-level-language-differences",title:e.jsx(e.Fragment,{children:"Low-level language differences"})},{depth:3,url:"#arithmetic",title:e.jsx(e.Fragment,{children:"Arithmetic"})},{depth:3,url:"#optional-support",title:e.jsx(e.Fragment,{children:"Optional support"})},{depth:3,url:"#iterable-dictionaries",title:e.jsx(e.Fragment,{children:"Iterable dictionaries"})},{depth:3,url:"#rich-support-for-type-utility-functions",title:e.jsx(e.Fragment,{children:"Rich support for type utility functions"})},{depth:3,url:"#argument-labelling",title:e.jsx(e.Fragment,{children:"Argument labelling"})},{depth:3,url:"#additional-resources",title:e.jsx(e.Fragment,{children:"Additional resources"})}];function i(n){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...n.components};return e.jsxs(e.Fragment,{children:[e.jsx(t.p,{children:"Cadence introduces a different way to approach smart contract development, which may feel unfamiliar to Solidity developers. There are fundamental mindset and platform differences, and also several new language features that have no real equivalent in Solidity. As a result, while you can make similar programs in Cadence as you could in Solidity, a direct translation from one to the other isn't possible - similar to how you could make a note-taking app in C or in JavaScript, but it wouldn't be possible to directly translate the C code into JavaScript. You'd have to write an entirely new program for a new paradigm."}),`
`,e.jsx(t.p,{children:"This guide outlines high level design and conceptual aspects of Flow and Cadence that are essential to understand, platform and integration differences, as well as detailed guidance on how to perform certain common Solidity development tasks using Cadence idioms. We also provide details on how to best leverage Cadence's unique features and how to avoid common pitfalls that may come up while transitioning."}),`
`,e.jsx(t.h2,{id:"conceptual-foundations-for-cadence",children:"Conceptual foundations for Cadence"}),`
`,e.jsxs(t.p,{children:["A fundamental difference to get used to when adjusting to Cadence from Solidity is ",e.jsx(t.strong,{children:"mindset"}),". Security and interoperability on Ethereum are designed around addresses (or more specifically, the account associated with an address), resulting in all contracts having to carefully track and evaluate access and authorizations."]}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{alt:"Ethereum Ownership",src:a,placeholder:"blur"})}),`
`,e.jsxs(t.p,{children:["Transactions are based on who authorized them, which is provided as ",e.jsx(t.code,{children:"msg.sender"})," in the transaction context. User-to-contract, or contract-to-contract interactions, must be explicitly coded ",e.jsx(t.strong,{children:"in the contract and in advance"})," to ensure the appropriate approvals have been made before interacting with a contract. The contract-based nature of storage means that user ownership in Ethereum is represented in a mapping (e.g., from owner to balance or token ID to owner). Put another way, ownership is tracked in ledger records similar to a person's bank balance. Crypto wallets help combine balances from multiple token types into a convenient view for the user."]}),`
`,e.jsxs(t.p,{children:["Cadence introduces new primitives and distinct functionalities, namely ",e.jsx(t.a,{href:"./language/resources",children:"Resources"})," and ",e.jsx(t.a,{href:"./language/capabilities",children:"Capabilities"}),", that are designed around Flow's account model. Resources are first-class language types, which are unique, non-copyable, and cannot be discarded. These properties make resources ideal for representing digital assets like currency or tokens that are always limited in number. Resources are always stored in account storage, and contracts control access to them using capabilities. Capabilities are another special type that secures protected resources without the need for tracking addresses. Cadence makes working with these straightforward and intuitive to those familiar with object-oriented programming languages."]}),`
`,e.jsx(t.h3,{id:"scripts-and-transactions",children:"Scripts and transactions"}),`
`,e.jsx(t.p,{children:"One of the most important (and powerful!) difference between Cadence and Solidity is that deployed contracts are not the only code being executed in the VM. Cadence offers scripts and transactions, which are written in Cadence and always exist offchain. However, they are the top-level code payload being executed by the execution runtime. Clients send scripts and transactions through the Flow Access API gRPC or REST endpoints, returning results to clients when applicable."}),`
`,e.jsx(t.p,{children:"Scripts and transactions enable more efficient and powerful ways to integrate dapps with the underlying blockchain, where contracts can more purely be thought of as services or components, with scripts or transactions becoming the dapp-specific API interface for chain interactions."}),`
`,e.jsxs(t.p,{children:["What this means is that you ",e.jsx(t.strong,{children:"don't have to predict the future"})," when writing your contracts and your ",e.jsx(t.strong,{children:"views aren't limited to functions in the contract"}),". Even more importantly, you can ",e.jsx(t.strong,{children:"write transactions that call multiple functions with multiple deployed contracts that you don't need to own"})," and are signed with one signature."]}),`
`,e.jsxs(t.p,{children:["Scripts are read-only in nature, requiring only a ",e.jsx(t.code,{children:"main"})," function declaration that performs ",e.jsx(t.a,{href:"https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_balance.cdc",children:"queries"})," against a chain state. For example:"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(t.pre,{className:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabIndex:"0",icon:'<svg viewBox="0 0 24 24"><path d="M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z" fill="currentColor" /></svg>',children:e.jsxs(t.code,{children:[e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"// This script reads the balance field of an account's ExampleToken Balance"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"import"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" FungibleToken "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"from"}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:' "../../contracts/FungibleToken.cdc"'})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"import"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" ExampleToken "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"from"}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:' "../../contracts/ExampleToken.cdc"'})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"access"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(all)"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"fun "}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"main"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(account: Address): UFix64 {"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"    let"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" acct "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" getAccount"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(account)"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"    let"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" vaultRef "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" acct.capabilities"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"        .borrow"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"<&"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"ExampleToken.Vault"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:">"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(ExampleToken.VaultPublicPath)"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"        ??"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" panic"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"("}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:'"Could not borrow Balance reference to the Vault"'}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:")"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"    return"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" vaultRef.balance"})]}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"}"})})]})})}),`
`,e.jsxs(t.p,{children:[e.jsx(t.a,{href:"https://github.com/onflow/flow-ft/tree/master/transactions",children:"Transactions"})," are an Atomic, Consistent, Isolated, and Durable (ACID) version of scripts having only ",e.jsx(t.code,{children:"prepare"})," and ",e.jsx(t.code,{children:"execute"})," functions that either succeed in full and mutate the chain state as described, or otherwise fail and mutate nothing. They also support a setting of ",e.jsx(t.code,{children:"pre"})," and ",e.jsx(t.code,{children:"post"})," conditions. In the following transaction example, ",e.jsx(t.code,{children:"ExampleToken"}),"s are deposited into multiple ",e.jsx(t.code,{children:"receiver"})," vaults for each address in the input map:"]}),`
`,e.jsx(e.Fragment,{children:e.jsx(t.pre,{className:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabIndex:"0",icon:'<svg viewBox="0 0 24 24"><path d="M14.23 12.004a2.236 2.236 0 0 1-2.235 2.236 2.236 2.236 0 0 1-2.236-2.236 2.236 2.236 0 0 1 2.235-2.236 2.236 2.236 0 0 1 2.236 2.236zm2.648-10.69c-1.346 0-3.107.96-4.888 2.622-1.78-1.653-3.542-2.602-4.887-2.602-.41 0-.783.093-1.106.278-1.375.793-1.683 3.264-.973 6.365C1.98 8.917 0 10.42 0 12.004c0 1.59 1.99 3.097 5.043 4.03-.704 3.113-.39 5.588.988 6.38.32.187.69.275 1.102.275 1.345 0 3.107-.96 4.888-2.624 1.78 1.654 3.542 2.603 4.887 2.603.41 0 .783-.09 1.106-.275 1.374-.792 1.683-3.263.973-6.365C22.02 15.096 24 13.59 24 12.004c0-1.59-1.99-3.097-5.043-4.032.704-3.11.39-5.587-.988-6.38-.318-.184-.688-.277-1.092-.278zm-.005 1.09v.006c.225 0 .406.044.558.127.666.382.955 1.835.73 3.704-.054.46-.142.945-.25 1.44-.96-.236-2.006-.417-3.107-.534-.66-.905-1.345-1.727-2.035-2.447 1.592-1.48 3.087-2.292 4.105-2.295zm-9.77.02c1.012 0 2.514.808 4.11 2.28-.686.72-1.37 1.537-2.02 2.442-1.107.117-2.154.298-3.113.538-.112-.49-.195-.964-.254-1.42-.23-1.868.054-3.32.714-3.707.19-.09.4-.127.563-.132zm4.882 3.05c.455.468.91.992 1.36 1.564-.44-.02-.89-.034-1.345-.034-.46 0-.915.01-1.36.034.44-.572.895-1.096 1.345-1.565zM12 8.1c.74 0 1.477.034 2.202.093.406.582.802 1.203 1.183 1.86.372.64.71 1.29 1.018 1.946-.308.655-.646 1.31-1.013 1.95-.38.66-.773 1.288-1.18 1.87-.728.063-1.466.098-2.21.098-.74 0-1.477-.035-2.202-.093-.406-.582-.802-1.204-1.183-1.86-.372-.64-.71-1.29-1.018-1.946.303-.657.646-1.313 1.013-1.954.38-.66.773-1.286 1.18-1.868.728-.064 1.466-.098 2.21-.098zm-3.635.254c-.24.377-.48.763-.704 1.16-.225.39-.435.782-.635 1.174-.265-.656-.49-1.31-.676-1.947.64-.15 1.315-.283 2.015-.386zm7.26 0c.695.103 1.365.23 2.006.387-.18.632-.405 1.282-.66 1.933-.2-.39-.41-.783-.64-1.174-.225-.392-.465-.774-.705-1.146zm3.063.675c.484.15.944.317 1.375.498 1.732.74 2.852 1.708 2.852 2.476-.005.768-1.125 1.74-2.857 2.475-.42.18-.88.342-1.355.493-.28-.958-.646-1.956-1.1-2.98.45-1.017.81-2.01 1.085-2.964zm-13.395.004c.278.96.645 1.957 1.1 2.98-.45 1.017-.812 2.01-1.086 2.964-.484-.15-.944-.318-1.37-.5-1.732-.737-2.852-1.706-2.852-2.474 0-.768 1.12-1.742 2.852-2.476.42-.18.88-.342 1.356-.494zm11.678 4.28c.265.657.49 1.312.676 1.948-.64.157-1.316.29-2.016.39.24-.375.48-.762.705-1.158.225-.39.435-.788.636-1.18zm-9.945.02c.2.392.41.783.64 1.175.23.39.465.772.705 1.143-.695-.102-1.365-.23-2.006-.386.18-.63.406-1.282.66-1.933zM17.92 16.32c.112.493.2.968.254 1.423.23 1.868-.054 3.32-.714 3.708-.147.09-.338.128-.563.128-1.012 0-2.514-.807-4.11-2.28.686-.72 1.37-1.536 2.02-2.44 1.107-.118 2.154-.3 3.113-.54zm-11.83.01c.96.234 2.006.415 3.107.532.66.905 1.345 1.727 2.035 2.446-1.595 1.483-3.092 2.295-4.11 2.295-.22-.005-.406-.05-.553-.132-.666-.38-.955-1.834-.73-3.703.054-.46.142-.944.25-1.438zm4.56.64c.44.02.89.034 1.345.034.46 0 .915-.01 1.36-.034-.44.572-.895 1.095-1.345 1.565-.455-.47-.91-.993-1.36-1.565z" fill="currentColor" /></svg>',children:e.jsxs(t.code,{children:[e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"import"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" FungibleToken "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"from"}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:' "../contracts/FungibleToken.cdc"'})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"import"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" ExampleToken "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"from"}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:' "../contracts/ExampleToken.cdc"'})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"/// Transfers tokens to a list of addresses specified in the `addressAmountMap` parameter"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"transaction"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(addressAmountMap: {Address: UFix64}) {"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"    // The Vault resource that holds the tokens that are being transferred"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"    let"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" vaultRef"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:":"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" auth"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"("}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"FungibleToken"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"."}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"Withdraw"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:") "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"&"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"ExampleToken"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"."}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"Vault"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"    prepare"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(signer: "}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"auth"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(BorrowValue) "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"&"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"Account) {"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"        // Get a reference to the signer's stored ExampleToken vault"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"        self.vaultRef "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" signer.storage.borrow"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"<"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"auth"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(FungibleToken.Withdraw) "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"&"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"ExampleToken.Vault"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:">"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"("})]}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"            from: ExampleToken.VaultStoragePath"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"       )     "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"??"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" panic"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"("}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:'"The signer does not store an ExampleToken.Vault object at the path "'})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"                    ."}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"concat"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(ExampleToken.VaultStoragePath."}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"toString"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"())"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"                    ."}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"concat"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"("}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:'". The signer must initialize their account with this vault first!"'}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"))"})]}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"    }"})}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"    execute {"})}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"        for address "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"in"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" addressAmountMap.keys {"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"            // Withdraw tokens from the signer's stored vault"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"            let"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" sentVault <- self.vaultRef.withdraw(amount"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:":"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" addressAmountMap"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"["}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"address"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"]!)"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"            // Get the recipient's public account object"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"            let"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" recipient "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" getAccount"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(address)"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"            // Get a reference to the recipient's Receiver"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"            let"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" receiverRef "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"="}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" recipient.capabilities"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"                .borrow"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"<&"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"{FungibleToken.Receiver}"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:">"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(ExampleToken.ReceiverPublicPath)"})]}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"                ??"}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:" panic"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"("}),e.jsx(t.span,{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"},children:`"Could not borrow receiver reference to the recipient's Vault"`}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:")"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#6A737D","--shiki-dark":"#6A737D"},children:"            // Deposit the withdrawn tokens in the recipient's receiver"})}),`
`,e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"            receiverRef."}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"deposit"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(from: "}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:"<-"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"sentVault)"})]}),`
`,e.jsx(t.span,{className:"line"}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"        }"})}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"    }"})}),`
`,e.jsx(t.span,{className:"line",children:e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"}"})})]})})}),`
`,e.jsx(t.p,{children:"Transactions can encompass an arbitrary number of withdrawals/deposits across multiple FTs, sending to multiple addresses or other more complex variations, all of which will succeed or fail in their entirety given their ACID properties."}),`
`,e.jsx(t.h2,{id:"flow-account-model",children:"Flow account model"}),`
`,e.jsxs(t.p,{children:["The ",e.jsx(t.a,{href:"https://developers.flow.com/build/basics/accounts.md",children:"Flow account model"}),` in Cadence combines storage for the keys and code ("smart contracts") associated with an account with storage for the assets owned by that account. That's right — in Cadence, your tokens are stored in your account, and not in a smart contract. Of course, smart contracts still define these assets and how they behave, but those assets can be securely stored in a user's account through the magic of Resources:`]}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{alt:"Account Structure",src:s,placeholder:"blur"})}),`
`,e.jsx(t.p,{children:"There is only one account type in Cadence that uses an account address, similar to an Externally-Owned-Account (EOA) address in Ethereum. Unlike Ethereum contracts, Cadence accounts directly store contract code. Accounts realize ownership on Flow by being the container where keys, resources, and contracts are stored onchain."}),`
`,e.jsx(t.h2,{id:"account",children:"Account"}),`
`,e.jsxs(t.p,{children:[e.jsx(t.code,{children:"Account"})," is the type that provides access to an account."]}),`
`,e.jsxs(t.p,{children:["The ",e.jsx(t.code,{children:"getAccount"})," function allows you to get access to the publicly available functions and fields of an account. For example, this allows querying an account's balance."]}),`
`,e.jsxs(t.p,{children:["An authorized ",e.jsx(t.code,{children:"Account"})," reference provides access and allows the management of the account's storage, key configuration, and contract code. An authorized ",e.jsx(t.code,{children:"Account"})," reference can only be acquired by signing a transaction. Capabilities ensure that resources held in an account can be safely shared and accessed."]}),`
`,e.jsx(t.h2,{id:"resources",children:"Resources"}),`
`,e.jsxs(t.p,{children:["Resources are unique, ",e.jsx(t.a,{href:"https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems",children:"linear types"})," that can never be copied or implicitly discarded, and can only be moved between accounts. Static checks during development flag an error for a failure to store a resource moved from an account if that resource is not appropriately moved back into storage for a same or new account, or explicitly destroyed. The run-time enforces the same strict rules in terms of allowed operations. Therefore, contract functions that do not properly handle resources in scope before exiting will abort, reverting the resource to the original storage. These features of resources make them perfect for representing tokens, both fungible and non-fungible. Ownership is tracked by where they are stored, and the assets can't be duplicated or accidentally lost since the language itself enforces correctness."]}),`
`,e.jsx(t.p,{children:"Flow encourages the storage of data and compute onchain and resource-types makes this easier than ever. Since resources are always stored in accounts, any data and code that exists in resource instances is seamlessly managed onchain without any explicit handling needed."}),`
`,e.jsx(t.h2,{id:"capability-based-access",children:"Capability-based access"}),`
`,e.jsxs(t.p,{children:["Remote access to stored objects is managed via ",e.jsx(t.a,{href:"./language/capabilities",children:"Capabilities"}),`. This means that if an account wants to be able to access another account's stored objects, it must have been provided with a valid capability to that object. Capabilities can be either public or private. An account can share a public capability if it wants to give all other accounts access. For example, it's common for an account to accept fungible token deposits from all sources via a public capability. Alternatively, an account can grant private capabilities to specific accounts in order to provide access to restricted functionality. For example, a non-fungible token (NFT) project often controls minting through an "administrator capability" that grants specific accounts the power to mint new tokens.`]}),`
`,e.jsx(t.h2,{id:"contract-standards",children:"Contract standards"}),`
`,e.jsxs(t.p,{children:["There are numerous widely-used contract standards established to benefit the ecosystem. For example, ",e.jsx(t.a,{href:"https://developers.flow.com/build/flow.md#flow-token",children:"Fungible Token"})," (FT) and ",e.jsx(t.a,{href:"https://developers.flow.com/build/flow.md#overview",children:"Non-Fungible Token"})," (NFT) are standards that are conceptually equivalent to Ethereum's ERC-20 and ERC-721 standards. Cadence's object-oriented design means standards apply through contract sub-types such as resources, resource interfaces, or other types declared in the contract standard. Standards can define and limit behavior and/or set conditions that implementations of the standard cannot violate."]}),`
`,e.jsxs(t.p,{children:["Detailed information about available standards and other core contracts can be found in the ",e.jsx(t.a,{href:"https://developers.flow.com/build/flow.md",children:"Introduction to Flow"}),"."]}),`
`,e.jsx(t.h3,{id:"nft-standard-and-metadata",children:"NFT standard and metadata"}),`
`,e.jsx(t.p,{children:"Solidity must manage NFT metadata offchain, and NFTs frequently link to IPFS-hosted JSON from onchain."}),`
`,e.jsxs(t.p,{children:["The Cadence NFT standard provides built-in support for metadata with specific types called ",e.jsx(t.a,{href:"https://developers.flow.com/build/flow.md",children:"views"}),". Views can be added to NFTs when minted and will always be available as part of the NFT. While metadata is stored onchain, graphics and video content are stored offchain. Cadence provides ",e.jsx(t.a,{href:"https://developers.flow.com/build/flow.md",children:"utility views"})," for both HTTP- and IPFS-based media storage, which remain linked to your NFT."]}),`
`,e.jsxs(t.p,{children:["Using NFT metadata views is a requirement to get listed in the ",e.jsx(t.a,{href:"https://www.flow-nft-catalog.com/",children:"Flow NFT Catalog"}),". Projects are encouraged to leverage the NFT catalog since wallets and other ecosystem partners can seamlessly integrate new collections added there with no input from project creators."]}),`
`,e.jsxs(t.p,{children:["NFT metadata on Flow opens the door to exciting new possibilities that help builders innovate. Check out this recent ",e.jsx(t.a,{href:"https://flow.com/post/flovatar-nft-flow-blockchain-case-study",children:"case study"})," where a community partner leveraged SVG-based metadata to make combined 2D + 3D versions of their PFPs, all onchain inside the NFTs' metadata!"]}),`
`,e.jsxs(t.p,{children:["Under most circumstances, NFTs bridged via the ",e.jsx(t.a,{href:"https://developers.flow.com/tutorials/cross-vm-apps/vm-bridge",children:"Cross-VM Bridge"})," from Flow Cadence to Flow EVM will automatically be provided with"]}),`
`,e.jsx(t.h2,{id:"security-and-access-control",children:"Security and access control"}),`
`,e.jsx(t.p,{children:"Decentralized application development places significant focus on security and access, which can fairly be described as security engineering. Understanding how resources, capabilities, and the account model solve this may not be obvious when viewed from a Solidity perspective."}),`
`,e.jsx(t.h3,{id:"msgsender-considered-harmful",children:"msg.sender considered harmful"}),`
`,e.jsx(t.p,{children:"The first question that every Solidity developer asks when they start programming in Cadence is:"}),`
`,e.jsx(t.p,{children:e.jsx(t.strong,{children:e.jsx(t.em,{children:"How do I get the account that authorized the transaction?"})})}),`
`,e.jsxs(t.p,{children:["In Ethereum, this account is referred to as ",e.jsx(t.code,{children:"msg.sender"})," and it informs the program flow in a function depending on who authorized it. Doing so is key to access and security, and is the basis of identity and ownership on Ethereum."]}),`
`,e.jsxs(t.p,{children:["Cadence does not support ",e.jsx(t.code,{children:"msg.sender"}),", and there is no transaction-level way for Cadence code to uniquely identify the calling account. Even if there was a way to access it, Cadence supports ",e.jsx(t.a,{href:"#multi-key-multi-signature-support",children:"multi-sig"})," transactions, meaning that a list of all the signers' accounts would be returned, making it impossible to identify a single authorizer."]}),`
`,e.jsxs(t.p,{children:["The reason ",e.jsx(t.code,{children:"msg.sender"})," is both unsupported and strongly advised against is that Cadence uses capabilities for access rather than addresses. The mindset change that developers need to adjust to is that a capability must first be obtained by the authorizing account (called the provider or signer in Cadence) from the contract that will require it, which then enables the requesting account to access the protected function or resource. This means the contract never needs to know who the signer is before proceeding because the capability ",e.jsx(t.strong,{children:"IS"})," the authorization."]}),`
`,e.jsx(t.p,{children:"In EVM, the contract grants access to an address or addresses, thus it must know and operate based on the address of the signer:"}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{alt:"Access-Based Security",src:o,placeholder:"blur"})}),`
`,e.jsxs(t.p,{children:["The ",e.jsx(t.a,{href:"https://en.wikipedia.org/wiki/Capability-based_security",children:"capability-based security"})," model of Cadence frames access in the opposite direction from the ",e.jsx(t.a,{href:"https://en.wikipedia.org/wiki/Access-control_list",children:"access-based security"})," model. Accounts are granted and store the capability to access and use functionality on the contract:"]}),`
`,e.jsx(t.p,{children:e.jsx(t.img,{alt:"Capability-Based Security",src:r,placeholder:"blur"})}),`
`,e.jsx(t.h3,{id:"access-control-using-capabilities",children:"Access control using capabilities"}),`
`,e.jsxs(t.p,{children:["Solidity lacks specific types or other primitives to aid with permission management. Developers must inline guards to ",e.jsx(t.code,{children:"require"})," at every function entry point, thus validating the ",e.jsx(t.code,{children:"msg.sender"})," of the transaction."]}),`
`,e.jsxs(t.p,{children:[e.jsx(t.a,{href:"./language/capabilities",children:"Capabilities"})," are defined by linking storage paths (namespaces for contract storage) to protected objects and then making that linked capability available to other accounts."]}),`
`,e.jsxs(t.p,{children:["Any account can get access to an account's public capabilities. Public capabilities are created using public paths (i.e., they have the domain ",e.jsx(t.code,{children:"public"}),"). For example, all accounts have a default public capability linked to the ",e.jsx(t.code,{children:"FlowToken.Vault"})," resource. This vault is exposed as a public ",e.jsx(t.a,{href:"./language/access-control#entitlements",children:"unentitled"})," capability, allowing any account to ",e.jsx(t.code,{children:"borrow()"})," a reference to the Vault to make a ",e.jsx(t.code,{children:"deposit()"}),". Since only the unentitled functions defined under the ",e.jsx(t.a,{href:"https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc#L167",children:e.jsx(t.code,{children:"FungibleToken.Vault"})})," interface are exposed, the borrower of the vault reference cannot call ",e.jsx(t.code,{children:"withdraw()"}),", since the method requires a ",e.jsx(t.code,{children:"Withdraw"})," entitled reference on the underlying vault."]}),`
`,e.jsxs(t.p,{children:["Accounts can share private capabilities, but must be specifically issued by the authorizing account. After ",e.jsx(t.a,{href:"./language/accounts/capabilities#issuing-capabilities",children:"issuing"}),", they can be obtained from authorized account objects (",e.jsx(t.code,{children:"Account"}),") but not public accounts (",e.jsx(t.code,{children:"PublicAccount"}),"). To share a private capability with another account, the owning account must ",e.jsx(t.code,{children:"publish"})," it to another account, which places it in the ",e.jsx(t.a,{href:"./language/accounts/inbox",children:"account inbox"})," (not to be mistaken with ",e.jsx(t.code,{children:"capabilities publish"}),"). The recipient can later claim the capability from the account inbox using the ",e.jsx(t.code,{children:"claim"})," function."]}),`
`,e.jsxs(t.p,{children:["Public Capabilities can be ",e.jsx(t.code,{children:"unpublished"})," and any capability can also be ",e.jsx(t.a,{href:"./design-patterns#capability-revocation",children:"revoked"})," by the creating account."]}),`
`,e.jsxs(t.p,{children:["To aid automation, events are emitted for completed ",e.jsx(t.code,{children:"publish"}),", ",e.jsx(t.code,{children:"claim"}),", and ",e.jsx(t.code,{children:"unpublish"})," actions for a Capability."]}),`
`,e.jsxs(t.p,{children:["Detailed information can be found in ",e.jsx(t.a,{href:"./language/capabilities",children:"Capabilities"}),"."]}),`
`,e.jsx(t.h3,{id:"hygiene-factors-for-protecting-value",children:"Hygiene factors for protecting value"}),`
`,e.jsxs(t.p,{children:["While capabilities grant account access to a protected resource, it's still necessary to impose controls on the value accessed through them. For example, if your use case requires delegating access to a ",e.jsx(t.code,{children:"FlowToken.Vault"})," to ",e.jsx(t.code,{children:"withdraw()"})," funds, it's important to limit the amount. Tokens implementing FT/NFT standards are the primary type of value being exchanged by accounts on Flow. The standard provides the primitives needed to implement capability-limiting best practices."]}),`
`,e.jsx(t.p,{children:e.jsx(t.strong,{children:"Token isolation"})}),`
`,e.jsxs(t.p,{children:["All FTs reside in a ",e.jsx(t.code,{children:"Vault"})," resource, and each different FT will exist as a separate ",e.jsx(t.code,{children:"Vault"})," in an account. Similarly, all NFTs implement a ",e.jsx(t.code,{children:"Collection"})," resource, in which those NFTs held by an account for that collection are stored."]}),`
`,e.jsxs(t.p,{children:["Whenever access to the ",e.jsx(t.code,{children:"withdraw()"})," function has to be delegated to another account, the simplest way to limit how many tokens of a given type can be withdrawn is to create a new ",e.jsx(t.code,{children:"Vault"})," resource for that token type and move a smaller amount of the tokens in the main token ",e.jsx(t.code,{children:"Vault"}),". A capability is then linked to that ",e.jsx(t.code,{children:"Vault"})," instance before being made available to another account."]}),`
`,e.jsxs(t.p,{children:["A similar pattern can be used for NFTs, where a new ",e.jsx(t.code,{children:"Collection"})," resource can be created into which only those NFTs that should be exposed are moved. A capability is then linked to that ",e.jsx(t.code,{children:"Collection"})," instance before being made available to another account."]}),`
`,e.jsx(t.p,{children:e.jsx(t.strong,{children:"Bespoke control strategies"})}),`
`,e.jsxs(t.p,{children:["For more complex use cases, you can create a new resource that implements the relevant interfaces to match those of the protected resource(s) that it wraps. The code for the new resource can then enforce limits as required and control how and when a delegation to the underlying resource occurs. One such example is the community-developed ",e.jsx(t.a,{href:"https://github.com/green-goo-dao/flow-utils/blob/main/contracts/ScopedFTProviders.cdc",children:e.jsx(t.code,{children:"ScopedFTProviders"})})," and ",e.jsx(t.a,{href:"https://github.com/green-goo-dao/flow-utils/blob/main/contracts/ScopedNFTProviders.cdc",children:e.jsx(t.code,{children:"ScoptedNFTProviders"})})," utility contracts."]}),`
`,e.jsx(t.h3,{id:"admin-roles",children:"Admin roles"}),`
`,e.jsxs(t.p,{children:["Compared to Solidity, creating an admin role in Cadence requires a little more code, all of which is encapsulated within a resource. The admin object design can be highly customized and employ capabilities and ",e.jsx(t.a,{href:"./language/access-control#entitlements",children:"entitlements"})," for fine-grained control, such as limiting access to individual functions, on a per-account basis if required. The complexity needed for admin roles may vary — for example, larger organizations may require more complex role-based-access schemes. The use of a resource in this context is key — the instance can't be copied, and the account with the first edition mint of the admin serves as the root admin. The admin can be implemented to mint additional admin resource instances, which only the root-admin can grant to selected user accounts via a capability. Conveniently, because the admin role is only accessible via a capability, it's easy to manage with ",e.jsx(t.a,{href:"./design-patterns#capability-revocation",children:"Capability Revocation"}),"."]}),`
`,e.jsxs(t.p,{children:["The admin role originates from the ",e.jsx(t.a,{href:"./design-patterns#init-singleton",children:"init singleton pattern"})," and uses the ",e.jsx(t.a,{href:"./design-patterns#capability-bootstrapping",children:"Capability Bootstrapping"})," pattern for making the Capability available to other accounts."]}),`
`,e.jsxs(t.p,{children:["An example admin role implementation is available in the ",e.jsx(t.a,{href:"https://cookbook.onflow.org/?preview=13",children:"Cadence cookbook"}),"."]}),`
`,e.jsx(t.h3,{id:"role-based-access",children:"Role-based access"}),`
`,e.jsxs(t.p,{children:["Implementing role-based access can be achieved by defining roles as resources managed by the root-admin account. Roles can provide limited access to functions, which guard other protected resources that include access levels and/or what is exposed, varying from role to role. The root admin can grant accounts access to individual roles through a private capability. Functions that the roles are permitted to invoke may be scoped as ",e.jsx(t.code,{children:"access(contract)"})," to enforce that they can only be called by code paths in the root-admin contract."]}),`
`,e.jsx(t.h2,{id:"other-best-practices-and-conventions",children:"Other best practices and conventions"}),`
`,e.jsx(t.p,{children:"Certain well-established best practices for Solidity may not apply or are handled differently."}),`
`,e.jsx(t.h3,{id:"check-effects-interactions",children:"Check effects interactions"}),`
`,e.jsxs(t.p,{children:["Solidity contracts must use the ",e.jsx(t.a,{href:"https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html",children:"check effect interaction"})," because functions are public by default and address-based access means that guards must exist when program flow concedes control to an external contract. There are two reasons why this is significantly less of a problem in Cadence. Functions are private by default, and the language provides a range of ",e.jsx(t.a,{href:"./language/access-control",children:"access scopes"}),". More importantly, ",e.jsx(t.em,{children:"risks associated with ceding control to an external contract"})," is an Ethereum phenomenon; the risk no longer applies. This is primarily because Cadence contracts are not static singletons, so control is never lost to another contract during the scope of a transaction."]}),`
`,e.jsx(t.h3,{id:"guard-check",children:"Guard check"}),`
`,e.jsxs(t.p,{children:["Solidity uses ",e.jsx(t.code,{children:"revert"}),", ",e.jsx(t.code,{children:"require"}),", and ",e.jsx(t.code,{children:"assert"})," to validate inputs. ",e.jsx(t.code,{children:"require"})," is a product of the address-based nature of Solidity, which capabilities replace. ",e.jsx(t.code,{children:"revert"})," is similar to Cadence's ",e.jsx(t.code,{children:"panic"})," in that a transaction is aborted. Cadence provides an ",e.jsx(t.code,{children:"assert"})," operator, which mirrors ",e.jsx(t.code,{children:"assert"})," in Solidity."]}),`
`,e.jsx(t.h3,{id:"modifiers",children:"Modifiers"}),`
`,e.jsx(t.p,{children:"Modifiers are extensively used in Solidity when enforcing pre-checks within a function. This is a powerful language feature. However, modifiers can also mutate a state, which introduces risks to the program control flow."}),`
`,e.jsxs(t.p,{children:["Cadence uses ",e.jsx(t.code,{children:"pre"})," and ",e.jsx(t.code,{children:"post"})," blocks to validate input values or the function execution outputs. Notably, a ",e.jsx(t.code,{children:"pre"})," and ",e.jsx(t.code,{children:"post"})," block prohibits the changing of a state and may only enforce conditions."]}),`
`,e.jsxs(t.p,{children:["Another difference is that modifiers in Solidity can be reused within the contract multiple times. Cadence ",e.jsx(t.code,{children:"pre"})," and ",e.jsx(t.code,{children:"post"})," blocks are associated with individual functions only, reducing the likelihood of errors but resulting in a small amount of code duplication."]}),`
`,e.jsx(t.h3,{id:"error-handling",children:"Error handling"}),`
`,e.jsx(t.p,{children:"Solidity offers a try/catch block to handle errors; however, there is presently no equivalent in Cadence."}),`
`,e.jsx(t.h2,{id:"integration-differences",children:"Integration differences"}),`
`,e.jsx(t.p,{children:"There are a few notable integration differences between Cadence and Solidity, which are described in the following sections."}),`
`,e.jsx(t.h3,{id:"contract-imports-and-dynamic-contract-borrowing",children:"Contract imports and dynamic contract borrowing"}),`
`,e.jsx(t.p,{children:"Contracts in Ethereum are similar to static singletons in that interactions happen directly between users and the functions declared on the contract instance itself. The object-oriented nature of Cadence means that contracts are more accurately viewed as imported dependencies. The imported contract makes its object graph available for the code at runtime. Rather than interacting with a contract singleton instance, account interactions to access capabilities are the primary integration entry point, allowing the user to interact with the returned objects."}),`
`,e.jsx(t.p,{children:"Dynamic borrowing of a contract inlines the loading of a contract based on its contract address. The loaded contract can be cast to the contract standard interface to which it conforms to (e.g., NFT standard) and then interacted with in the same way if it were statically imported. Consider the implications of this for the composability of contracts."}),`
`,e.jsxs(t.p,{children:["Detailed information about deploying, updating, removing, or borrowing contracts can be found in ",e.jsx(t.a,{href:"./language/contracts",children:"Contracts"}),"."]}),`
`,e.jsx(t.h3,{id:"multi-key-multi-signature-support",children:"Multi-key, multi-signature support"}),`
`,e.jsxs(t.p,{children:["Solidity supports only one kind of multi-signature scheme where ",e.jsx(t.code,{children:"n"})," out of ",e.jsx(t.code,{children:"m"})," (assuming ",e.jsx(t.code,{children:"m >= n"}),") approvals need to be obtained to execute the transaction from the multi-signature smart contract. The most used multi-signature smart contract in the Ethereum ecosystem is the Gnosis ",e.jsx(t.a,{href:"https://github.com/safe-global/safe-contracts/blob/main/contracts/Safe.sol",children:"safe contract"}),". However, Solidity lacks support for signature aggregation or BLS signature schemes."]}),`
`,e.jsx(t.p,{children:"Cadence offers a wide range of options to implement various multi-signature schemes, including:"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsx(t.li,{children:"Inherent support for multi-sign transactions."}),`
`,e.jsx(t.li,{children:"Resource transfer scheme."}),`
`,e.jsx(t.li,{children:"Inherent support of the BLS signature scheme."}),`
`]}),`
`,e.jsx(t.p,{children:"Flow account keys have assigned weights, where a 1000 unit weight is the cumulative weight needed from signing keys to execute a transaction successfully. One can divide weights arbitrarily across multiple keys and distribute those partial weighted keys to authorized signers. When signing the transaction, all signers must sign the transaction together in a short period of time in order for the cumulative weight to reach 1000 units."}),`
`,e.jsxs(t.p,{children:["See the ",e.jsx(t.a,{href:"./language/crypto#bls-multi-signature",children:"BLS Signature scheme"})," for a detailed overview of the inherent support of BLS signatures."]}),`
`,e.jsx(t.p,{children:e.jsx(t.strong,{children:"Resource transfer scheme"})}),`
`,e.jsx(t.p,{children:"The main limitation of multi-signature transactions is that signatures must all be made for the transaction within a relatively short time window. If this window is missed, the transaction will abort. The resource transfer scheme is very similar to the Solidity multi-signature smart contract. A resource is created that has the functionality to proxy the execution of a fund transfer. This resource is handed from one signer to the next to collect signatures. Once the threshold of required signatures is met, the transaction is executed. The main drawback with this approach is that it does not support the execution of arbitrary functionality."}),`
`,e.jsx(t.h2,{id:"other-platform-differences",children:"Other platform differences"}),`
`,e.jsx(t.p,{children:"The following differences, which are unrelated to implementing Cadence contracts, are useful to understand in the context of application design."}),`
`,e.jsx(t.h3,{id:"events",children:"Events"}),`
`,e.jsxs(t.p,{children:["Flow uses ",e.jsx(t.a,{href:"./language/events",children:"events"})," extensively to provide real-time signals to offchain systems about particular actions that occurred during a transaction. The main difference in Flow is that events remain part of the history and are not purged from storage. Events can be populated with arbitrary data that will assist consumers of the event. Builders are encouraged to leverage events for seamless UX as users perform transactions."]}),`
`,e.jsx(t.h3,{id:"contract-upgradeability",children:"Contract upgradeability"}),`
`,e.jsx(t.p,{children:"Flow supports limited upgradability of Cadence contracts, which is most helpful during development. The following function shows how an account owner can update a contract:"}),`
`,e.jsx(e.Fragment,{children:e.jsx(t.pre,{className:"shiki shiki-themes github-light github-dark",style:{"--shiki-light":"#24292e","--shiki-dark":"#e1e4e8","--shiki-light-bg":"#fff","--shiki-dark-bg":"#24292e"},tabIndex:"0",icon:'<svg viewBox="0 0 24 24"><path d="M 6,1 C 4.354992,1 3,2.354992 3,4 v 16 c 0,1.645008 1.354992,3 3,3 h 12 c 1.645008,0 3,-1.354992 3,-3 V 8 7 A 1.0001,1.0001 0 0 0 20.707031,6.2929687 l -5,-5 A 1.0001,1.0001 0 0 0 15,1 h -1 z m 0,2 h 7 v 3 c 0,1.645008 1.354992,3 3,3 h 3 v 11 c 0,0.564129 -0.435871,1 -1,1 H 6 C 5.4358712,21 5,20.564129 5,20 V 4 C 5,3.4358712 5.4358712,3 6,3 Z M 15,3.4140625 18.585937,7 H 16 C 15.435871,7 15,6.5641288 15,6 Z" fill="currentColor" /></svg>',children:e.jsx(t.code,{children:e.jsxs(t.span,{className:"line",children:[e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"fun "}),e.jsx(t.span,{style:{"--shiki-light":"#6F42C1","--shiki-dark":"#B392F0"},children:"update"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:"(name"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:":"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" String, code"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:":"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" [UInt8])"}),e.jsx(t.span,{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"},children:":"}),e.jsx(t.span,{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"},children:" DeployedContract"})]})})})}),`
`,e.jsx(t.p,{children:"Upgrades are analyzed for prohibited changes once uploaded for an upgrade. Upgradeability is still an early-phase feature, which will continue to improve over time."}),`
`,e.jsx(t.p,{children:"To enforce immutability once a contract is tested and ready to deploy, account owners can optionally revoke keys from the account containing the contract."}),`
`,e.jsxs(t.p,{children:["Detailed information about the cadence upgradeability is available in ",e.jsx(t.a,{href:"./language/contract-updatability",children:"Contract Updatability"}),"."]}),`
`,e.jsx(t.h3,{id:"account-key-formulation",children:"Account key formulation"}),`
`,e.jsx(t.p,{children:"In EVM-based chains, an address is derived from a cryptographically generated public key and can have a single private key, supporting one type of signature curve (i.e., ECDSA). They are not verifiable offchain and typos/truncation in an address may result in funds being lost."}),`
`,e.jsx(t.p,{children:"Flow account addresses have a special format and are verifiable offchain. Verifying address format validity can be done using an error detection algorithm based on linear code. While this does not also confirm that an address is active onchain, the extra verifiability is a useful safeguard."}),`
`,e.jsx(t.h3,{id:"contract-size-constraints",children:"Contract size constraints"}),`
`,e.jsxs(t.p,{children:["Solidity developers will be well aware of the ",e.jsx(t.a,{href:"https://eips.ethereum.org/EIPS/eip-170",children:"EIP-170"})," deployable contract bytecode size limit of 24KB. This can burden builders who need to optimize contract bytecode size, sometimes even requiring a re-design of contracts to break it into smaller contract parts."]}),`
`,e.jsx(t.p,{children:"By contrast, Cadence has no inherent or defined smart contract size limit. However, it is restricted by the transaction size limit, which is 1.5MB. With very rare exceptions, it's unlikely that this limit would pose a problem to those developing Cadence contracts. Should it be needed, there is a known way to deploy a contract exceeding 1.5MB, which we will document at a later time."}),`
`,e.jsx(t.h2,{id:"low-level-language-differences",children:"Low-level language differences"}),`
`,e.jsx(t.p,{children:"There are several language differences between Solidity and Cadence, which are described in the following sections."}),`
`,e.jsx(t.h3,{id:"arithmetic",children:"Arithmetic"}),`
`,e.jsx(t.p,{children:"Historically, Solidity, smart contracts lost millions of dollars because of improper handling of arithmetic under/overflows. Contemporary Solidity versions offer inbuilt handling of under/overflow for arithmetic operations."}),`
`,e.jsxs(t.p,{children:["Cadence implements ",e.jsx(t.a,{href:"https://en.wikipedia.org/wiki/Saturation_arithmetic",children:"saturating math"}),", which avoids overflow/underflow."]}),`
`,e.jsx(t.h3,{id:"optional-support",children:"Optional support"}),`
`,e.jsxs(t.p,{children:[e.jsx(t.a,{href:"./language/control-flow#optional-binding",children:"Optional binding"})," provides built-in conditional handling of nil values. Regular data types in Cadence must always have a value and cannot be nil. Optionals enable variables or constants that might contain a certain type or a nil value. Optional bindings have two cases: either there is a value or there is nothing — they fork program flow similar to ",e.jsx(t.code,{children:"if nil; else; end;"}),"."]}),`
`,e.jsx(t.h3,{id:"iterable-dictionaries",children:"Iterable dictionaries"}),`
`,e.jsxs(t.p,{children:["Solidity offers the mapping type, however it is not iterable. Because of that, dapp developers have to maintain offchain tracking to have access to keys. This also pushes builders to create custom data types like ",e.jsx(t.code,{children:"EnumerableMap"}),", which adds to gas costs."]}),`
`,e.jsxs(t.p,{children:["Cadence offers the ",e.jsx(t.a,{href:"./language/control-flow",children:"Dictionary"})," type, an unordered collection of key-value associations, which is iterable."]}),`
`,e.jsx(t.h3,{id:"rich-support-for-type-utility-functions",children:"Rich support for type utility functions"}),`
`,e.jsx(t.p,{children:"Cadence offers numerous native-type utility functions to simplify development. For example, the String type provides:"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"utf8"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"length"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"concat()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"slice()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"split()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"replaceAll()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"join()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"decodeHex()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"encodeHex()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"fromCharacters()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"fromUTF8()"})}),`
`,e.jsx(t.li,{children:e.jsx(t.code,{children:"toLower()"})}),`
`]}),`
`,e.jsx(t.h3,{id:"argument-labelling",children:"Argument labelling"}),`
`,e.jsxs(t.p,{children:["Argument labels in Cadence help to disambiguate input values. They make code more readable and explicit. They also eliminate confusion around the order of arguments when working with the same type. They must be included in the function call, but this restriction can be skipped if the label is preceded by ",e.jsx(t.code,{children:"_ "})," on its declaration."]}),`
`,e.jsx(t.p,{children:"For example:"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:["if ",e.jsx(t.code,{children:"fun foo(balance: UFix64)"}),", which is called as ",e.jsx(t.code,{children:"self.foo(balance: 30.0)"})]}),`
`,e.jsxs(t.li,{children:["then, ",e.jsx(t.code,{children:"fun foo( _balance: UFix64)"})," can be called as ",e.jsx(t.code,{children:"self.foo(balance: 30.0)"})," or as ",e.jsx(t.code,{children:"self.foo(30.0)"}),"."]}),`
`]}),`
`,e.jsx(t.p,{children:"One thing to note about argument labelling is that function overloading is not currently supported in Cadence. This means that functions with the same name but different argument labels are not allowed, which is an available feature in Solidity."}),`
`,e.jsx(t.h3,{id:"additional-resources",children:"Additional resources"}),`
`,e.jsxs(t.ul,{children:[`
`,e.jsxs(t.li,{children:[e.jsx(t.a,{href:"https://flow.com/engineering-blogs/flow-blockchain-programming-language-smart-contract-cadence-solidity-comparison-ethereum",children:"On-Chain Token Transfer Deep Dive"})," — Cadence or Solidity"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.a,{href:"https://flow.com/post/implementing-the-bored-ape-yacht-club-smart-contract-in-cadence",children:"Bored Ape Yacht Club"})," — Implementing a smart contract in Cadence"]}),`
`,e.jsxs(t.li,{children:[e.jsx(t.a,{href:"https://www.quicknode.com/guides/other-chains/flow/account-abstraction-on-flow#account-abstraction-on-ethereum-vs-flow",children:"Comparing AA on Ethereum vs Flow"})," — Quicknode's account abstraction on the Flow blockchain"]}),`
`]}),`
`]})}function p(n={}){const{wrapper:t}=n.components||{};return t?e.jsx(t,{...n,children:e.jsx(i,{...n})}):i(n)}export{l as _markdown,p as default,d as frontmatter,h as structuredData,u as toc};
